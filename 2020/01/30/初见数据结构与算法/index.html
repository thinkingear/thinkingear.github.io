<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构与算法," />










<meta name="description" content="摘要：初学者快速上手数据结构与算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="初见数据结构与算法">
<meta property="og:url" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Gear&#39;s blog">
<meta property="og:description" content="摘要：初学者快速上手数据结构与算法。">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E5%AD%98%E6%8A%BD%E5%B1%89.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%B2%E7%AA%81.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8D%E6%98%8E%E9%A3%9F%E7%89%A9.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E6%A0%87.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E4%B8%AA%E6%B0%B4%E6%9E%9C.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/py%E4%BA%A4%E6%98%93.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A5%BD%E7%9A%84%E6%A0%91.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9D%8F%E7%9A%84%E6%A0%91.png">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E4%BB%AC.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E6%95%A3%E5%88%97%E8%A1%A8.jpg">
<meta property="article:published_time" content="2020-01-30T04:11:49.101Z">
<meta property="article:modified_time" content="2020-02-07T02:44:42.282Z">
<meta property="article:author" content="齿维">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E5%AD%98%E6%8A%BD%E5%B1%89.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/30/初见数据结构与算法/"/>





  <title>初见数据结构与算法 | Gear's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gear's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">东方×V家×番剧×计算机</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于我
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="齿维">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gear's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">初见数据结构与算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-30T12:11:49+08:00">
                2020-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="leancloud_visitors" data-flag-title="初见数据结构与算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                <span class="post-meta-item-text">热度 </span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>摘要</strong>：初学者快速上手数据结构与算法。</p>
<a id="more"></a>
<p><strong>阅前须知</strong>：本文仅提供学习数据结构与算法的一个初步的知识框架，仅供参考，实际效果因人而异。该文章所参考的书籍绝大部分来自《算法图解》，少部分来自《算法导论》。本文所有的代码示例均用 Python 语言编写，全文也只有五处很短的代码块，代码落地程度不高，代码量不够的读者也可以阅读。</p>
<blockquote>
<p>  我承认，精准且严谨的定义固然是重要的，因为所有与之相关的理解都要建立在这个定义的基础上。但有时有些晦涩的定义直接上手可能会非常地棘手，因此可以先从定义的相关的应用或实例入手，通过<strong>合理恰当的打比方</strong>的方式，先对定义产生初步的了解，再通过练习不断地修正，力图接近真实的定义，最终可以达到所谓事半功倍的效果。<br>
  因此，我想表达的是，文章可能会出现几处严谨性欠佳的描述，我会在那后面力争把它“圆”回来，并附上一个或者多个认可度较高的定义及出处。</p>
</blockquote>
<h1 id="何为算法">何为算法</h1>
<p>《算法导论》对算法的定义为：非形式地说，算法就是任何良性定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样的算法就是把输入转换成输出的计算步骤的一个序列。<br>
  讲真，上面这段定义看不看懂不重要，算法其实就是一组完成任务的指令，任何代码片段都可视为算法。如果还是没有感觉，可以姑且认为算法就是函数三要素中的<strong>对应法则 f</strong> 即可，我们只需知道算法的重要性以及应用就够了。<br>
  算法可谓是现代信息技术的灵魂，它指挥着各种各样可处理的数据。一个<strong>优秀</strong>的算法要求在<strong>尽可能短的时间和空间</strong>内结束并返回<strong>正确的结果</strong>。于是，评判一个算法优劣的指标——<strong>时间复杂度</strong>和<strong>空间复杂度</strong>，应运而生。其中，时间复杂度常常用<strong>大 O 表示法</strong>进行合理地量化并表示。</p>
<p>​		枚举，搜索，贪心，随机，递归，二分，分治，动态规划。这些都是一些最基础的算法思想，它们本身不仅是具体落地的算法，更是算法框架。这些框架之间相互组合，就又能延伸出非常多五彩斑斓的算法。这其中思想的奇妙性就在于，它并不是一个确实存在的东西，却又能任意转化成令人醍醐灌顶的产物，简洁但深刻。<br>
  论暴力，目前谁都比不过电子计算机的运算能力。一台普通的 Laptop，每秒也能进行上亿次计算。上面说的所有的算法，本质都是在计算机变态一般的计算力的基础上，对数据的存储及其处理所做的一些列的优化过程。<br>
  <strong>枚举</strong>，也是要讲究方法的。比如，明明这样的情况已经非法，但如果还是在一味地枚举，就徒劳地增加了计算机运算负担。通过有限次的枚举，最终返回正确结果的过程叫做搜索。而中途遇到非法情况，从而退回重置到原来的某一个步骤的过程叫做回溯。枚举时所用的数据一般是特意选择后得到的，这样的选择策略一共有两种：贪心 以及 随机。贪心既是贪取利益最大的选择，随机则是通过随机的方式进行选择。<br>
  <strong>分治</strong>，分而治之的简称，是将大问题分为子问题 以大化小的算法思路，也是使用频率非常高的算法。比如当我们翻阅字典时，除了依靠目录查询，人们更喜欢将字典从中间摊开放在桌面上，进行所谓的二分查找。这里的二分查找就用到了分治的思想。又比如之后要介绍的动态规划算法，即将问题拆分为子问题，在计算过程中利用之前计算过的结果，避免重复计算。分治大家庭中，递归的地位也比较高。这是个非常有意思的算法思想。形式上就是一系列相似的问题，通过我调用我自己，像套娃一样层层拆分，直到达到基线条件。调用栈的层数越多，问题就越简单的，且最上层的问题是可以直接解出来的，但调用栈层数过多时，递归的效率就会非常低下。某种程度上，递归就是以大博小，动态规划则是以小博大。递归典型的例子就是汉诺塔问题，当然更具体的内容之后会安排上。</p>
<h2 id="大-O-表示法">大 O 表示法</h2>
<p>​		设待处理的数据规模为 n，我们<strong>不关心</strong>计算机每次处理一份数据时所花的时间到底有多长，<strong>只关心</strong>计算机处理这 n 个数据时所耗费的总操作数。一般用大写的 “O” 表示。</p>
<p>下面是常见算法的时间复杂度，其中 O(log n) 中的 log n 习惯认为是以 2 为底的对数。</p>
<p>![](初见数据结构与算法/大 O 表示法.jpg)</p>
<p>​		可能一个算法的实际时间复杂度为 O(3*n! + 0.5*n log n + 7)。那么<strong>规定该算法的时间复杂度就是当 n 趋于无穷大时，在上面常见时间复杂度中与其同阶无穷大的时间复杂度</strong>。这样化简后的时间复杂度表示为 O(n!) 即可。值得一提的是，O(1) 表示<strong>常量时间</strong>，意为无论数据规模有多大，这个算法只需要一步就能搞定。</p>
<p>​		前面提到的《算法导论》中，有句话特别在理：<strong>Having a solid base of algorithm knowledge and technique is one characteristic that separates the truly skilled programmers from the novices.</strong><br>
意为，是否具有扎实的算法知识和技术基础，是区分真正熟练的程序员与新手的一项重要特征。</p>
<h1 id="数组与链表">数组与链表</h1>
<p>​		你需要将<strong>内存空间</strong>想象成宾馆储物抽屉柜，每个抽屉只能储存一个物品。如下图所示。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E5%AD%98%E6%8A%BD%E5%B1%89.jpg" alt></p>
<p>​		你可以选两种储存方式，一种是使用连续地进行储存，这种存储结构的管理方式好处和坏处都很明显，好处是你只需要记住第一个物品的位置，就可以瞬间知道第几个物品的位置在哪里。坏处是当你抽屉组的最前端和最后段都有物品时，如若需要增加物品，你只能把所有元素全部搬到更大的连续的抽屉组中，非常费力，当然你也可以提前申请足够大的空间，但如若最后用不上那么多，即是对空间的极度浪费。<br>
  另外一种是离散地进行储存，并且上一个抽屉储存着下一个抽屉的位置，即 当查看第 n 个抽屉的内容时，就顺势直到第 n+1 个抽屉的位置在哪里了。这种存储结构的优势是你没有前一种存储方式的顾虑，可以随意在任意位置添加元素，删除第 n 个元素时，只需将第 n-1 个抽屉记录第 n+1 个位置即可。但如若想知道第 n 个抽屉位置，就需要 n-1 个抽屉的位置，以此类推，需要全部遍历，效率比较低下，不支持随机访问。<br>
  第一种就像是数据结构中的<strong>数组</strong>，第二种就像是数据结构中的<strong>链表</strong>。如若经常需要从头遍历所有元素，用链表会更好一些，但若经常需要随机访问元素，则一般需要用数组。或者更一般地来说，如果打算创建下来之后不会再修改其长度，就用数组，否则用链表。<br>
  数组和链表还被用来实现其他数据结构，比如 Facebook 实际使用的是什么呢？很可能是十多个数据库，他们居于众多不同数据结构：散列表、B数等。数组和链表使这些更复杂的数据结构的基石。</p>
<h1 id="递归">递归</h1>
<p>​		每个递归算法都由两个不可或缺的部分组成：<strong>基线条件（base case）和递归条件（recursivecase）</strong>。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>
  只要是数据结构，都有属于自己的操作。例如数组和链表就有读取、插入、删除、修改等操作。而对于<strong>栈</strong>来说，它的操作只有<strong>压入(push)<strong>和</strong>弹出(pop)</strong>。当一个栈用于存储多个函数的变量时，被称为<strong>调用栈</strong>。因为每当你调用函数时，计算机都将函数调用所涉及的变量的值存储到内存中。当一个函数调用返回时，就从栈的顶部弹出。<br>
  使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择。一种是将递归化为循环解决，另一种是<u>尾递归</u>，当然这就是另一个故事了。</p>
<h1 id="分治">分治</h1>
<p>​		有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的 算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。<strong>分而治之</strong>（divide and conquer，D&amp;C）是你学习的第一种通用的问题解决方法。快速排序就是使用分而治之策略的一种优雅的排序算法。<br>
  D&amp;C 思路是递归的，使用 D&amp;C 解决问题的过程包括两个步骤：</p>
<ol>
<li>找出简单的基线条件。</li>
<li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li>
</ol>
<p>​		编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，有必要检查一下基线条件是不是这样的。</p>
<h2 id="函数式编程">函数式编程</h2>
<p>诸如 <strong>Haskell</strong> 等函数式编程语言没有循环，因此你只能使用递归来编写类循环。例如，函数 sum 可以这样编写。</p>
<pre><code>sum[] = 0
sum(x:xs) = x + (sum xs)
# 用函数式程序设计语言 Haskell 所编写的 sum 函数。

sum arr = if  arr == []
            then 0
            else (head arr) + (sum (tail arr))
# 用循环编写 sum 函数。
</code></pre>
<p>​		<strong>归纳证明</strong>是一种证明算法行之有效的证明方式。它分为基线条件和归纳条件，在数学领域中被称为第一类数学归纳法。归纳证明常常与 D&amp;C 协同发挥作用。</p>
<h2 id="快速排序">快速排序</h2>
<p>C语言标准库中的 <strong>qsort</strong> 函数实现的就是快速排序，是一种比选择排序快得多的排序算法，快排的平均大 O 运行时间为 O(n*log n )。其基本步骤为：</p>
<ol>
<li>
<p>数组的 pivot[^基准值]的选取。</p>
</li>
<li>
<p>分别创建两个数组，其中包含除 pivot 外小于等于 pivot 的，以及大于 pivot 的。</p>
</li>
<li>
<p>分别对这两个数组进行快排。</p>
</li>
</ol>
<p>​		快速排序的实际运行时间很大程度上都由 pivot 决定，如果 pivot 一直选取数组第一个元素时，它的栈的高度就为 n，每层的操作数也为 n==[这里不太懂]==，最终的运行时间为 O(n<sup>2</sup>)。而如果每次都选取中间的元素时，栈的高度就是 log n，每层的操作数还是 n==[同上]==。</p>
<h2 id="散列表">散列表</h2>
<p>​		<strong>散列表</strong>，又称<strong>哈希表(hash table)</strong>，由散列函数和数组构成。任意一个可处理的输入数据，经过散列函数后，可将输入数据映射到数组中某个位置的内存地址中，内存地址又可以另外指向其它具体的数据，这个数据则被称作是<strong>散列值</strong>，简称<strong>值</strong>。充当<strong>值</strong>的数据类型可以是<strong>任意类型</strong>。而前面输入数据则被称作是<strong>键</strong>，充当<strong>键</strong>的数据类型只能是<strong>不可变类型</strong>。		<strong>理想的散列函数</strong>能够保证所有不同的键映射的内存地址互不相同。但正因为是理想，所以现实情况中很难办到。当不同键映射到同一处内存地址时，就会产生<strong>冲突</strong>。要想化解冲突，只需将数组这个位置的内存地址指向一个<strong>链表</strong>即可，之后在这个链表中存储各自想要储存的值即可。如下图所示。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%B2%E7%AA%81.jpg" alt></p>
<p>但如果某个链表的所涉及的元素过多，查找散列表的速度会比较慢，以至于在最糟情况时，散列表的各种操作的运行时间都是 O(n)。想要尽可能地避免冲突，需要有<strong>较低的装填因子</strong>以及<strong>良好的散列函数</strong>，当然这就是另一个故事了。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">散列表(平均情况)</th>
<th style="text-align:center">散列表(最糟情况)</th>
<th style="text-align:center">数组</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读取</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
<h2 id="散列表的应用">散列表的应用</h2>
<ul>
<li>将散列表用于查找
<ul>
<li>储存电话号码和联系人似乎用散列表是比较好的，这是个简单例子。不妨稍微谈一下高级话题，比如 DNS 解析[^DNS resolution]。访问像 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 这样的网站时，计算机要先将域名转换为 IP 地址,即 74.125.239.133，转换的过程其实就是将网址映射到 IP 地址上去。因此用散列表的特性来做是极好的。</li>
</ul>
</li>
<li>将散列表用作缓存
<ul>
<li>缓存是一种常用的加速方式，几乎任何的大型网站都会使用缓存，而缓存的数据则会储存在散列表中。当你访问 Facebook 的网页时，你会先接入他们的服务器，如果某个网页所有用户看到的都应该是一样的，那就会将事先保存好的网页展示给你，就像是所有人的登陆界面一样。否则服务器就对网页做些处理，将生成的网页展示给你，比如你的个人空间。这就是缓存，它能使用户更快地看到网页，也因此 Facebook 需要做的计算量更少。</li>
</ul>
</li>
<li>防止重复</li>
</ul>
<h2 id="广度优先搜索">广度优先搜索</h2>
<blockquote>
<p>根据作者所知道的算法中，图算法应该是最有用的，而广度优先搜索就是图算法的一种，它能够找出两样东西之间的最短距离。</p>
</blockquote>
<p>**最短路径问题：**像从旧金山双子峰到金门大桥的最少换成次数，或者去你朋友家的最短路径，再或者是国际象棋中把对方将杀死的最少步数。都被称为是最短路径问题。</p>
<p>​	要解决最短路径问题通常需要两个步骤：</p>
<ol>
<li>使用图来建立问题模型</li>
<li>使用广度优先搜索解决问题</li>
</ol>
<p><strong>何为图？</strong><br>
<strong>图用于模拟不同的东西是如何相连的</strong>，它由<strong>节点</strong>和<strong>边</strong>组成，一个节点所<strong>直接指出去</strong>的所有节点统一称作是<strong>邻居</strong>。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE2.jpg" alt></p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE1.jpg" alt></p>
<h2 id="何为广度优先搜索">何为广度优先搜索</h2>
<p>广度优先搜索是一种用于<strong>图</strong>的<strong>查找算法</strong>，它可以解决两类问题：</p>
<ol>
<li>
<p>从节点 A 出发，有通往节点 B 的路径吗？</p>
</li>
<li>
<p>如果有，那么从节点 A 出发，通往节点 B 的哪条路径最短？</p>
</li>
</ol>
<p>​		以节点 A 为中心，节点 A 的邻居被称为是节点 A 的<strong>一度关系</strong>，邻居的邻居被称为是<strong>二度关系，以此类推</strong>。在广度优先搜索看来，<strong>一度关系胜过二度关系，二度胜过三度</strong>，因此它会先在一度关系中查找节点 B，一度没有就找二度，二度没有就去三度，<strong>直到找到为止或者所有的节点都遍历过一遍为止</strong>。</p>
<p><strong>队列：<strong>队列的工作原理与现实生活中的队列完全相同，是一种数据结构。它只支持两种操作，即</strong>入队</strong>和<strong>出队</strong>。Python 中可以从 cllections 库中引入 deque 函数来创建一个双端队列。</p>
<p>​		为了实现广度优先搜索算法，我们需要先实现图，再去通过队列的先进先出的特性来实现算法。</p>
<h2 id="实现图">实现图</h2>
<p>​		没有邻居的节点被称为是<strong>有向图</strong>，互为邻居的节点被称为是<strong>无向图</strong>。像这样一个节点对应多个节点的结构像极了映射，因此我们可以用<strong>散列表</strong>来储存图，将每个节点设为键，每个节点的邻居设为值。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE3.jpg" alt></p>
<h2 id="实现算法">实现算法</h2>
<p>先用队列按照几度关系的顺序依次将节点入队。具体步骤为：</p>
<ol>
<li>创建一个搜索队列</li>
<li>将中心节点的邻居添加至队列中</li>
<li>只要搜索队列不是空的，建立循环
<ol>
<li>将一个节点 popleft() 赋值给变量 P</li>
<li>检查 P 有没有被检查过
<ol>
<li>检查 P 是不是<strong>目标节点</strong>
<ol>
<li>如果是则返回 True</li>
<li>如果不是则将 P 的邻居添加到队列中</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>返回 False</li>
</ol>
<p>​		在最糟糕的情况下，你需要遍历整个图，也就是说每条<strong>边</strong>都要走一次，并且你需要对每个节点进行依次检查，于是时间复杂度为 <strong>O(V + E)</strong>，其中 V(vertical)为节点数，E(eadg) 为边数。</p>
<h1 id="狄克斯特拉算法">狄克斯特拉算法</h1>
<p>​		如果说广度优先搜索是解决<strong>最短路径</strong>问题，那么狄克斯特拉算法就是解决<strong>最快路径</strong>问题。应用狄克斯特拉算法时，图中每条边都有与之相关联的<strong>数字</strong>，这叫做权重。并且，带权重的图被称为是<strong>加权图</strong>，不带权重的图被称为时<strong>非加权图</strong>。值得一提的是狄克斯特拉算法只适用于<strong>有向无环图</strong>且<strong>无负权边</strong>的情况。</p>
<p>狄克斯特拉算法包含以下几个步骤。</p>
<ol>
<li>设中心节点为 A，列出如下表格。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">节点</th>
<th style="text-align:center">父节点</th>
<th style="text-align:center">耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A 的邻居 B</td>
<td style="text-align:center">A</td>
<td style="text-align:center">α</td>
</tr>
<tr>
<td style="text-align:center">A 的邻居 C</td>
<td style="text-align:center">A</td>
<td style="text-align:center">β</td>
</tr>
<tr>
<td style="text-align:center">非 A 的邻居 D</td>
<td style="text-align:center">其它</td>
<td style="text-align:center">∞</td>
</tr>
<tr>
<td style="text-align:center">目标节点</td>
<td style="text-align:center">其它</td>
<td style="text-align:center">∞</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>循环开始：
<ol>
<li>找出所有节点中**“耗时”最少**的节点，在这里不妨设 α &lt; β，因此我们很轻松地找出了节点 B。</li>
<li>计算 A 到 B 每个邻居的“耗时”，若 结果 小于 原有结果，则<strong>更新相应节点的“耗时”与“父节点”的值。</strong></li>
<li>由于 B 的邻居都已更新完毕，因此 节点 B <strong>不再参与</strong>下一轮的循环。<strong>直到所有节点的邻居更新完毕。</strong></li>
</ol>
</li>
<li>根据目标节点的父节点，向前依次<strong>追踪节点</strong>，直到某个节点的父节点为 中心节点 A，得出完整最短路线。</li>
</ol>
<p>Q：为什么算法实现的充分条件是<strong>有向无环图</strong>？</p>
<p>A：若节点与节点之间相互成“环”，那么每循环“环”一次总耗时就要无意义地增加，这样的路径不可能是<strong>最快路径</strong>。</p>
<p>Q：为什么算法实现的充分条件是<strong>不存在负权边</strong>？</p>
<p>A：若含有负权边，那么在后续的循环中，有可能会更新之前已经淘汰掉的节点的“耗时”以及“父节点”的值，如上述的 节点 B，这时理应要再对 节点 B 进行一次检查，可是由于 节点 B 已经淘汰掉了，因此无法更新 B 的邻居们。所以可能会使<strong>真实结果</strong>和<strong>实际演算结果</strong>产生不小的出入（其实就是贪心的锅，导致只能求得近似解），狄克斯特拉算法看起来就像是出了 bug 一样。因此，应对这种情况，我们必须换一个算法来实现——<strong>贝尔曼-福德 算法</strong>，当然这就是另一个故事了。</p>
<h2 id="关于实现">关于实现</h2>
<p>​		以表格作为算法的出发点，需要用到三个散列表来装填三种数据，即 graph , parents , costs，而其中 graph 还需要存储各个边的权重，因此需要再套一层散列表，即 第一层 = 键 : 值 = <strong>节点 : 第二层散列表</strong>，第二层 = 键 : 值 = <strong>邻居 : 边的权重</strong>。</p>
<h1 id="贪心算法">贪心算法</h1>
<p>​		贪心算法，又称贪婪算法，即 每步都选择的<strong>局部最优解</strong>，最后得到<strong>近似</strong>全局最优解或<strong>全局最优解</strong>，采取的是一种步步为“赢”的策略手段。<br>
  在一些问题中，有时你不得不需要计算出所有合法情况下的解。这种问题就被称作为 <strong>NP完全问题</strong>。在每次计算出的解集中，从中选出最符合题意条件的解，从而求得精确最优解。而往往这种暴力算法所带来的运行速度都是非常糟糕的，这时需要采用贪心算法。虽然多数情况下只能求得近似解，但时间复杂度要比纯暴力计算好看得多。</p>
<h3 id="NP完全问题模型—集合覆盖问题">NP完全问题模型—集合覆盖问题</h3>
<p>​		假设你办了个广播节目，要让全美 50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。广播台的名单 demo 如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">广播台</th>
<th style="text-align:center">覆盖的周</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KONWE</td>
<td style="text-align:center">ID,NV,UT</td>
</tr>
<tr>
<td style="text-align:center">KTWO</td>
<td style="text-align:center">WA,ID,MT</td>
</tr>
<tr>
<td style="text-align:center">KTHREE</td>
<td style="text-align:center">OR,NV,CA</td>
</tr>
<tr>
<td style="text-align:center">KFOUR</td>
<td style="text-align:center">NV,UT</td>
</tr>
<tr>
<td style="text-align:center">KFIVE</td>
<td style="text-align:center">CA,AZ</td>
</tr>
</tbody>
</table>
<p>​		每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。而我们呢现在的问题是如何找出覆盖全美 50个州的最小广播台集合，这听起来很容易，但其实运算量极大，具体方法余下。</p>
<ol>
<li>列出每个可能的广播台集合，这被称为 幂集（power set）。因此，可能的子集有 2<sup>n</sup>个（包括空集）。</li>
<li>在这些 2<sup>n</sup>个子集中，选中覆盖全美 50个州的最小集合。</li>
</ol>
<p>​		当然，n 在 0~10 的区间范围内还好说，但当 n 超过了这个范围，实际操作数将急剧增加，更为痛苦的是，目前<strong>没有任何算法</strong>可以足够快地解决这个问题。这时就需要**近似算法（approximation algorithm）**解决类似的问题，具体方法如下。</p>
<ol>
<li>选出这样一个广播台，即 它覆盖了最多的未覆盖州。即便这个广播台也同时覆盖了一些已覆盖的州，也没有关系。</li>
<li>重复第一步，直到覆盖了所有的州。</li>
</ol>
<p>具体的 Python 代码实现如下。</p>
<pre><code>states_needed = set([&quot;mt&quot;, &quot;wa&quot;, &quot;or&quot;, &quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;, &quot;ca&quot;,&quot;az&quot;])  # 传入一个数组，并转换为集合。
arr = set([1, 2, 2, 3, 3, 3])

stations = {}  # 需要有可供选择的广播台清单，使用散列表来表示它。
stations[&quot;kone&quot;] = set([&quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;])
stations[&quot;ktwo&quot;] = set([&quot;wa&quot;, &quot;id&quot;, &quot;mt&quot;])
stations[&quot;kthree&quot;] = set([&quot;or&quot;, &quot;nv&quot;, &quot;ca&quot;])
stations[&quot;kfour&quot;] = set([&quot;nv&quot;, &quot;ut&quot;])
stations[&quot;kfive&quot;] = set([&quot;ca&quot;, &quot;az&quot;])
final_stations = set()  # 需要一个集合来储存最终选择的广播台。

while states_needed:  # 不断地循环，直到states_needed为空。
    best_station = None     # 准备遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台存储在 best_station 中。
    states_covered = set()
    for station, states in stations.items():  # for循环迭代每个广播台，并确定它是否是最佳的广播台。
        covered = states_needed &amp; states  # covered 包含当前广播台覆盖的一系列还未覆盖的州
        if len(covered) &gt; len(states_covered):  # 检查该广播台覆盖的州是否比 best_station 多。
            best_station = station
            states_covered = covered  # states_covered 包含该广播台覆盖的所有未覆盖的州。
            states_needed -= states_covered  # 更新 states_needed。
            final_stations.add(best_station)

print(final_stations)  # 输出结果为 set(['ktwo', 'kthree', 'kone', 'kfive'])
</code></pre>
<h3 id="NP完全问题模型—旅行商问题">NP完全问题模型—旅行商问题</h3>
<p>​		有一位旅行商，他需要前往 n个城市，同时保证旅程最短。因此他需要考虑各种各样可能的顺序情况，而对于每种顺序，他都要计算总旅程，再挑选出旅程最短的路线，那么很明显，他需要考虑 n! 个顺序情况。<br>
  针对这种问题，当 n 比较大时，可以采取贪婪算法，具体步骤为。</p>
<ol>
<li>选定一个起点城市。</li>
<li>去往离起点城市最近的城市，并将起点城市更新为该城市。</li>
<li>重复上述步骤。</li>
</ol>
<h3 id="如何识别NP完全问题">如何识别NP完全问题</h3>
<p>​		旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。<br>
  通常来说，用 贪婪算法 解决一个 NP完全问题并不难，而真正难的部分则是意识到这是个 NP完全问题。下面列出几个判断 NP完全问题的经验性规律。</p>
<p>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</p>
<ul>
<li>涉及“所有组合”的问题通常是NP完全问题。</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li>
<li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<blockquote>
<p>动态规划相较于其它算法来说，是属于比较重要，但同时也比较麻烦的一种算法。因此这里先了解一个例子再根据这个例子具体说明可能会好理解一点。</p>
</blockquote>
<h3 id="背包问题">背包问题</h3>
<h4 id="描述">描述</h4>
<p>​		假设你现在是一个不折不扣的小偷，晚上进商城准备偷东西，你的背包很神奇，它装东西本领只和这个东西的重量有关，不妨限定你的背包最多只能装 4kg的东西。下面是你想偷的东西的清单，每件商品只有一个。</p>
<table>
<thead>
<tr>
<th style="text-align:center">商品</th>
<th style="text-align:center">音响(S)</th>
<th style="text-align:center">笔记本电脑(L)</th>
<th style="text-align:center">吉他(G)</th>
<th style="text-align:center">IPhone(I)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">价格</td>
<td style="text-align:center">￥3000</td>
<td style="text-align:center">￥2000</td>
<td style="text-align:center">￥1500</td>
<td style="text-align:center">￥2000</td>
</tr>
<tr>
<td style="text-align:center">重量</td>
<td style="text-align:center">4kg</td>
<td style="text-align:center">3kg</td>
<td style="text-align:center">1kg</td>
<td style="text-align:center">1kg</td>
</tr>
</tbody>
</table>
<p>​		你的目标很明确，在有限的容量里装入尽可能多的有价值的物品。因为你明白这其中要满足某种配比才有可能是问题的最优解（比如，拿走一个 笔记本电脑 和一个 IPhone 才可能是最赚的），但你不确定。因此，你掏出纸和笔打算写一个动态规划网格。我承认这可能很突然，但先照着做一下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">商品/容量</th>
<th style="text-align:center">1kg</th>
<th style="text-align:center">2kg</th>
<th style="text-align:center">3kg</th>
<th style="text-align:center">4kg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">吉他</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">音响</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">笔记本电脑</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IPhone</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>​		其中，网格的各行为商品，各列为不同容量（1~4kg）的背包。首先要声明的是，待会儿要填满这里所有的单元格，因为它们将帮助你计算背包的最大价值。<strong>你要做的事情是</strong>：逐行填写，填完一行再填下一行。填 a 行 b 列时，你假定现在只能偷 <strong>小于等于 a 行</strong> 的商品，且你的背包大小只有 <strong>b kg</strong>。举个例子，当你填 <strong>第二行 第三列</strong> 的单元格时，你只能偷 <strong>吉他</strong> 以及 <strong>音响</strong>，并且你的背包容量只有 <strong>3kg</strong>，这时将所能带走的最大价值填入所对应的单元格中。</p>
<h4 id="揭晓">揭晓</h4>
<p>​		看完上面有点懵是正常的，觉得意义不明也有可能，因此需要适当“放”出来一点东西出来缓和以下。<br>
  动态规划讲究将原问题划分为 n 个子问题，所以我们才将背包容量这个<strong>限制条件</strong>划分成 4 大块。通过解决第 1 个子问题，<strong>保存</strong>结果，接着解决第 2 个子问题时可以<strong>调用</strong>之前的结果，类似于尾递归。因此填表的时候沿着一列往下走时，最大价值不可能降低。因为每次迭代时，你都存储了当前的最大价值，最大价值不可能比之前还要低。<br>
  值得一提的是，这 n 个子问题之间必须是相互独立且<strong>离散</strong>的。拿背包问题举例，如果拿了笔记本电脑之后再拿 IPhone 时电脑会爆炸，简言之就是电脑的价值会受手机的影响，这样的情况是用不了动态规划的。<br>
  设行数为 i，列数为 j，cell 表示表格， α 为当前物品的价值，β 为当前物品的所占空间，则：<strong>cell[i][j] = max{cell[i-1][j] , α + cell[i-1][j-β]}</strong>， 即<br>
<strong>每个单元格的价值 = 上一个单元格的价值 与 当前商品的价值 + 剩余空间的价值 的两者的较大值</strong>。<br>
  按照上述公式所填写的完整的表格如下，其中最大价值为￥4000，也就是说当你的容量只有 4kg 的背包，装一个 IPhone 和一个笔记本电脑时，收益才能达到最大化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">商品/容量</th>
<th style="text-align:center">1kg</th>
<th style="text-align:center">2kg</th>
<th style="text-align:center">3kg</th>
<th style="text-align:center">4kg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">吉他(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
</tr>
<tr>
<td style="text-align:center">音响(S)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥3000</td>
</tr>
<tr>
<td style="text-align:center">笔记本电脑(L)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥1500(G)</td>
<td style="text-align:center">￥2000(L)</td>
<td style="text-align:center">￥3500(LG)</td>
</tr>
<tr>
<td style="text-align:center">IPhone(I)</td>
<td style="text-align:center">￥3500(I)</td>
<td style="text-align:center">￥3500(IG)</td>
<td style="text-align:center">￥3500(IG)</td>
<td style="text-align:center">￥4000(IL)</td>
</tr>
</tbody>
</table>
<p>​		在背包问题中，任意调换某两行都不会影响最终结果，甚至逐列填写单元格也没关系，但在其它动态规划模型中就不一定成立了。你也可以在最后一行添加一个任意一个商品而不影响上面的计算结果，当然前提是这件商品的重量是个整数，如果不是整数则要重新划分价格区间。</p>
<h3 id="动态规划问题">动态规划问题</h3>
<ol>
<li>需要在给定<strong>约束条件</strong>下<strong>优化某种指标</strong>时。例如在背包问题中，你必须在背包容量给定的情况下，拿到价值最高的商品。</li>
<li>问题可分解为<strong>离散</strong>的子问题时。</li>
</ol>
<h3 id="动态规划的认知">动态规划的认知</h3>
<ol>
<li><strong>每种动态规划解决方案都涉及网络</strong>。</li>
<li><strong>单元格中的值</strong>通常就是你要<strong>优化的值</strong>。在背包问题中，单元格的值为商品的价值。</li>
<li>每个单元格都是一个子问题，因此你该考虑如何将问题分成子问题，这有助于你找出网格坐标轴。</li>
<li>没有放之四海而皆准的计算动态规划解决方案的公式。</li>
</ol>
<h3 id="动态规划问题建模">动态规划问题建模</h3>
<p>遇到动态规划问题时首先要问自己这么几个问题：</p>
<ol>
<li>单元格中的值是什么？或者说 在动态规划中，你要将哪个<strong>指标最大化</strong>？</li>
<li>如何将这个问题划分为子问题？</li>
<li>网格的坐标轴是什么？</li>
<li>应该使用什么样的公式来填充每个单元格？</li>
</ol>
<h3 id="所谓费曼算法">所谓费曼算法</h3>
<p>​		动态规划实际上比较棘手的部分就是对动态规划问题的建模这一块，但有时你就是不确定具体到底该怎么做。这时，计算机科学家会开玩笑说：不妨就使用<strong>费曼算法（Feynman algorithm）</strong>。这个算法是以著名物理学家 理查德·费曼 命名的，算法具体步骤如下。</p>
<ol>
<li>将问题写下来。</li>
<li>好好思考。</li>
<li>将答案写下来。</li>
</ol>
<p>由此我们知道，有些算法并非精确的解决步骤，而是会帮助你理清思路的框架。</p>
<p>​		接下来我们再来讨论三个动态规划问题，其中第一个和背包问题类似，其余两种则需要重新建模。</p>
<h3 id="旅游行程最优化">旅游行程最优化</h3>
<p>​		加入你要去伦敦度假，假期两天，但你想去游览的地方有很多。由于你没法前往每个地方游览，因此如何在有限的时间内，游览地方的评分总和最高是你的目标。具体行程如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名胜</th>
<th style="text-align:center">威斯敏斯特教堂(W)</th>
<th style="text-align:center">环球剧场(G)</th>
<th style="text-align:center">英国国家美术馆(N)</th>
<th style="text-align:center">大英博物馆(B)</th>
<th style="text-align:center">圣保罗大教堂(S)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">时间</td>
<td style="text-align:center">0.5天</td>
<td style="text-align:center">0.5天</td>
<td style="text-align:center">1天</td>
<td style="text-align:center">2天</td>
<td style="text-align:center">0.5天</td>
</tr>
<tr>
<td style="text-align:center">评分</td>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>根据上面的清单以及背包问题的公式，我们可以非常轻松地填满如下表格。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名胜/时间</th>
<th style="text-align:center">1/2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3/2</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">威斯敏斯特教堂(W)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">7(W)</td>
</tr>
<tr>
<td style="text-align:center">环球剧场(G)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">13(WG)</td>
<td style="text-align:center">13(WG)</td>
<td style="text-align:center">13(WG)</td>
</tr>
<tr>
<td style="text-align:center">英国国家美术馆(N)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">13(WG)</td>
<td style="text-align:center">16(WN)</td>
<td style="text-align:center">22(WGN)</td>
</tr>
<tr>
<td style="text-align:center">大英博物馆(B)</td>
<td style="text-align:center">7(W)</td>
<td style="text-align:center">13(WG)</td>
<td style="text-align:center">16(WN)</td>
<td style="text-align:center">22(WGN)</td>
</tr>
<tr>
<td style="text-align:center">圣保罗大教堂(S)</td>
<td style="text-align:center">8(S)</td>
<td style="text-align:center">15(WS)</td>
<td style="text-align:center">21(WGS)</td>
<td style="text-align:center">24(WNS)</td>
</tr>
</tbody>
</table>
<h3 id="最长公共子串">最长公共子串</h3>
<blockquote>
<p>有必要提前声明的是，<strong>最长公共子串</strong>讲究的是字符之间的连续性的，即 <strong>绝对顺序</strong>。相反，<strong>最长公共子序列</strong>讲究的是字符之间的<strong>相对顺序</strong>。举个例子，fosh 和 fish 的最长公共子串的长度为 2，最长公共子序列的长度为 3。fosh 和 fort 的最长公共子串的长度也是 2，但最长公共子序列的长度只有 2。</p>
</blockquote>
<p>​		FISH 和 HISH 的最长公共子串的长度为多少？相信我们都可以一眼看出来，但对于计算机来说是要设计专门的算法来处理这样的问题的。<br>
  首先判断这本质上应该是个动态规划问题，毫无疑问，这些个单词都可以分为单个离散的字符。并且，对于 FISH 来说 HISH 本身就是约束条件，反过来也一样。所要优化的指标当然也就是两者的 公共子串的长度。</p>
<p>根据以上分析判断这是个动态规划问题之后直接上网格表。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">H</th>
<th style="text-align:center">I</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>针对单元格中索要填入的的值，思考公式是什么。<strong>再次强调一下，公式只是表象，其内部还是子问题的保存和调用的一个尾递归。</strong></p>
<ol>
<li>如果两个字母不相同时，值 =  0。</li>
<li>如果两个字母相同时，值 = 左上角单元格的值 + 1。</li>
</ol>
<p>实现这个公式的伪代码类似于下面这样。</p>
<pre><code>if word_a[j] == word_b[j]:	# 两个字母相同
    cell[i][j] = cell[i-1][j-1] + 1
else:
    cell[i][j] = 0			# 两个字母不同
</code></pre>
<p>根据公式不难填满得到如下表格。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">H</th>
<th style="text-align:center">I</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>同理，HISH 和 VISTA 的最长公共子串如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">V</th>
<th style="text-align:center">I</th>
<th style="text-align:center">S</th>
<th style="text-align:center">T</th>
<th style="text-align:center">A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>需要注意的是，最终的答案并不总在最后一个单元格中。</p>
<h3 id="最长公共子序列">最长公共子序列</h3>
<p>同样，利用上面的分析方法，也可以得到动态规划最长公共子序列的公式。</p>
<ol>
<li>如果两个字母不同，就选择上方和左边的单元格的值较大的哪个。</li>
<li>如果两个字母相同，就将当前单元格的值设置为左上方的单元格的值加 1。</li>
</ol>
<p>公式伪代码如下。</p>
<pre><code>if word_a[i] == word_b[j]:	# 两个字母相同
    cell[i][j] = cell[i-1][j-1] + 1
else:						# 两个字母不同
    cell[i][j] = max(cell[i-1][j],cell[i][j-1])
</code></pre>
<p>求 FOSH 和 FORT 的最长公共子序列的长度的网格如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">F</th>
<th style="text-align:center">O</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>求 FOSH 和 FISH 的最长公共子序列的长度的网格如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">F</th>
<th style="text-align:center">O</th>
<th style="text-align:center">S</th>
<th style="text-align:center">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<h3 id="动态规划的实际应用">动态规划的实际应用</h3>
<ul>
<li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。</li>
<li>你使用过诸如 git diff 等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li>
<li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li>
<li>你使用过诸如 Microsoft Word 等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li>
</ul>
<h2 id="K最近邻算法">K最近邻算法</h2>
<blockquote>
<p>​		有些人说 网易云音乐 和 哔哩哔哩 有着一些 朋友交易。~~（举个例子，自己刚在哔哩哔哩看了触手猴翻奏了萃香的曲子的视频，不一会儿打开网易云音乐，首页上就推荐了 东方萃梦想/碎月/萃梦想 的同人曲歌单。）~~这其中的机制就和 <strong>K最近邻算法</strong>有关。</p>
</blockquote>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8D%E6%98%8E%E9%A3%9F%E7%89%A9.png" alt></p>
<p>​		如上图，现在桌子上有一个水果，现在它只可能是橙子或者柚子中的一种，你不能直接问卖水果的人。手头上已知的条件是：**柚子通常比橙子更大、更红。**现在的问题是它最有可能是橙子还是柚子？</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E6%A0%87.png" alt></p>
<p>​		不妨在脑内想象一个这么样的图表，其中 O 为橙子，G 为柚子，横坐标为大小，纵坐标为颜色的深浅。注意到，<strong>坐标轴是连续的，而水果则抽象成了一些离散的点，或者说向量。</strong><br>
  那么如何大致判断这个神秘的水锅到底是什么呢？其实非常简单，不妨找一下离 神秘水果所表示的点 最近的三个水果，然后比较以下那种水果的种类更多即可。若假定 3个水果中，有两个都是橙子，那么这个神秘水果很有可能就是橙子。</p>
<h3 id="KNN算法">KNN算法</h3>
<p>​		在判断那个水果的种类的过程中，其实已经使用了 K最近邻（k-nearest neighbours, KNN）算法。利用自然语言描述刚刚的 KNN算法过程如下。</p>
<ol>
<li>需要对一个水果进行分类。</li>
<li>查看它 K个最近的邻居。</li>
<li>在这些邻居中，橙子多余柚子，因此它很可能是橙子。</li>
</ol>
<p><strong>要对东西进行分类时，可以首先考虑采用 KNN算法。<strong>你可以使用 KNN 来做两项基本工作——<strong>分类</strong>和</strong>回归（regression）</strong>。</p>
<ul>
<li>分类就是编组；</li>
<li>回归就是预测结果。</li>
</ul>
<h3 id="特征抽取">特征抽取</h3>
<p>抽取特征时，要挑准合适的特征。</p>
<ol>
<li>抓准与之紧密相关的特征；</li>
<li>不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断它们是否喜欢动作片）。</li>
</ol>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E4%B8%AA%E6%B0%B4%E6%9E%9C.jpg" alt></p>
<p>​		在前面的水果示例中，你根据个头和颜色来比较水果，换言之，你比较的特征是个头和颜色。现在假设有三个水果，你可<strong>抽取它们的特征</strong>。很明显，A 和 B 直观看起来十分相似，但事实上具体多少相似我们还是可以通过 KNN算法 来解决。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.jpg" alt></p>
<p>​		横坐标表示 个头，纵坐标表示 红的程度，因此，我们可以把这三个点用坐标表示出来。</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(2,2)</td>
<td style="text-align:center">(2,1)</td>
<td style="text-align:center">(4,5)</td>
</tr>
</tbody>
</table>
<p>​		再利用毕达哥拉斯公式不难算出每两点之间空间距离，并标在图表上。因为 A 与 B 两点之间的距离最短，因此它们俩是最像的，这也印证了之间的直觉。</p>
<h3 id="回归">回归</h3>
<p>​		假定你在你的老家卖冰棍，由于是夏天，卖地比较火，因此每天都要进货一些新的冰棍。每天的进货量由下面几个指标进行预测。</p>
<ol>
<li>天气指数 1~5（数字越大 代表 气温越高）；</li>
<li>是否是周末或节假日（周末或节假日为 1，否则为 0）；</li>
<li>有无活动（有为 1，否则为 0）。</li>
</ol>
<p>​		之后，你测了 1个月的数据，记录了在各种不同的日子里卖出的冰棍数量。在这 30天的容量中，你选出 6天的数据作为样本，如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(5,1,0)</td>
<td style="text-align:center">(3,1,1)</td>
<td style="text-align:center">(1,1,0)</td>
<td style="text-align:center">(4,0,1)</td>
<td style="text-align:center">(4,0,0)</td>
<td style="text-align:center">(2,0,0)</td>
</tr>
<tr>
<td style="text-align:center">300根</td>
<td style="text-align:center">225根</td>
<td style="text-align:center">75根</td>
<td style="text-align:center">200根</td>
<td style="text-align:center">150根</td>
<td style="text-align:center">50根</td>
</tr>
</tbody>
</table>
<p>​		今天是周末，气温比较高，店里也没有办什么活动，点坐标为（4,1,0）。根据以上数据，你要预测今天大概能卖出去多少根冰棍。只要学过高中数学，就知道这就是个典型的回归问题，但有稍微有点不一样。由于之前说过 KNN算法就是用来解决<strong>编组</strong>和<strong>回归</strong>问题的，因此我们要用 KNN算法来解决。<br>
  利用毕达哥拉斯公式可以算出“今天”与A,B,C,D,E,F点之间的距离，如下所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>​		K 取 4 时，与（4,1,0）最近的邻居为 A、B、D 和 E。将这些天售出的冰棍数平均，结果为 218.75。<strong>这就是回归（regression）。</strong></p>
<h3 id="余弦相似度">余弦相似度</h3>
<p>​		前面计算两位用户的距离时，使用的都是<strong>距离公式</strong>。但在实际工作中，则经常会使用**余弦相似度（cosine similarity）**来量化两位用户的相似程度。余弦相似度不计算两个矢量的距离，而比较它们角度，如果要深入研究，那就是另一个话题了。</p>
<p>​		到这里不妨试着猜想一下开头提及的原理。网易云首先为每个注册的用户生成一个“用户画像”（Persona），即 将用户的每个具体信息抽象成标签，利用这些标签将用户形象具体化，从而为用户提供有针对性的服务。其中将每个具体信息抽象成标签的过程可能就要用到 K最近邻算法，不过这里的空间维数可能要达到千以上的数量级，并且每一维都有各自的权重。同理，哔哩哔哩也可能采用这样机制。<br>
  但哔哩哔哩和网易云音乐可能没有直接的关系。不妨假定在网易云音乐中，用户A 与 用户B 之间的标签十分相似。相似到什么程度呢？一旦 A “喜欢”了一首歌，就会立即反映到当天 B 的推荐歌曲中。接下来的说法要建立在一个前提之上，就是 这种类型的歌曲的听众 可以映射到 哔哩哔哩 的一个较小的“圈子”中。比如，喜欢听 二刺螈 的曲子的人 在哔哩哔哩中可能是混“番剧”这个圈子的。那么就有这种可能，十月新番 在 哔哩哔哩 准时开播，假定 番剧 和 OP 是同时上架的，A 第一时间追了一集之后马上去网易云音乐对 OP 点了“喜欢”。在这之后，B 也追完了，无意打开网易云发现首页上竟然有 自己正在追的动画的 OP，于是在曲子的评论中不禁如下感叹。（当然这不是我，<s>废话。</s>）<br>
<img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/py%E4%BA%A4%E6%98%93.png" alt></p>
<h3 id="简述机器学习">简述机器学习</h3>
<p>​		KNN算法在神奇的机器学习领域也占有一定的比重。<strong>机器学习</strong>皆在让计算机更聪明。<strong>创建推荐系统</strong>，就是个机器学习的例子。</p>
<h4 id="OCR">OCR</h4>
<p>​		OCR 指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我们来看一个例子。请看下面的数字。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.jpg" alt></p>
<p>如何自动识别出这个数字是什么呢？我们当然可以使用 KNN。</p>
<ol>
<li>浏览大量的数字图像，将这些数字的特征提取出来。这在机器学习中被称之为<strong>训练（training）</strong>。</li>
<li>遇到新图像时，提取该图像的特征，再找出它最近的邻居都是谁。</li>
</ol>
<p>​		与前面的水果示例相比，OCR 中的特征提取明显要复杂得多得多，但再复杂的技术也是基于 KNN 等简单理念的。而这些理念也可用于语音识别和人脸识别。当你将照片你上传到 Facebook 时，它有时候能够自动标出照片中的任务，这正是机器学习在发挥作用。</p>
<h4 id="创建垃圾邮件过滤器">创建垃圾邮件过滤器</h4>
<p>​		垃圾邮件过滤器用的并非 KNN 算法，而是另一种基本算法——<strong>朴素贝叶斯分类器（Naive Bayes classifier）</strong>。大多数机器学习算法都包括训练的步骤：要让计算机完成任务，必须先训练它。垃圾邮件过滤器也不再例外，因此你需要使用一定量的数据对这个分类器进行训练。垃圾邮件过滤器可以计算出一个任意一个邮件为垃圾邮件的概率，其应用领域与 KNN 相似。<br>
  你甚至还可以用朴素贝叶斯分类器对之前提到的水果进行分类：假设有一个又红又大的水果，它是柚子的概率是多少呢？……</p>
<h4 id="预测股票市场">预测股票市场</h4>
<p>未来很难预测，由于涉及的变量太多，这几乎是不可能完成的任务。</p>
<h2 id="最后再介绍十种数据结构和算法">最后再介绍十种数据结构和算法</h2>
<h3 id="树">树</h3>
<p>​		每当用户登录自己的 B 站 账号时，都要从庞大的数据中去查找，并判断是否存在这样 ID。倘若你要设计 B 站 用户的登陆系统，你会选择什么样的<strong>数据结构</strong>来存储用户 ID 以及 算法用来查找 ID。<br>
  如果使用二分查找，并使用极其庞大的数组来存储数据，那么注销和注册一个 ID 将是个极其麻烦的工作。为此，有人设计了一种名为**二叉查找树（binary search tree）**的数据结构，来减轻算法的负担。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<p>​		二叉查找树类似于上面这样。这种数据结构形象地表示出来之后长相酷似“树”，因此命名为二叉查找树，其实是一种变异的“链表”。也拜这种结构所赐，使得数据的增删变得极其地方便。其中，树的最顶端被称为<strong>根节点</strong>，其余节点被称为<strong>子节点</strong>。而<strong>对于其中每个节点，左子节点的值都比它小，右子节点的值都比它大。</strong><br>
  对于树的查找，其原理与二分查找相似，因此<strong>平均</strong>时间复杂度都为 O(log n)。举个例子，假设我要在上面 5个数据中查找“Maggie”。为此，我首先检查根节点是否为“Maggie”，发现匹配失败之后，发现“Maggie”应该排在“David”的后面，因此我往右边找。“Maggie”应该排在“Manning”前面，于是接着往左边找，最终找到了“Maggie”。<br>
  与其它大部分数据结构不同的是，树自己本身是存在<strong>优劣</strong>的，即 有好的“树”，也有“坏”的树。<strong>一颗树中两个分叉的子树数量比例越高，树的性能就越佳。</strong></p>
<p>👍🌲⬇️</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A5%BD%E7%9A%84%E6%A0%91.png" alt></p>
<p>👎🌲⬇️</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9D%8F%E7%9A%84%E6%A0%91.png" alt></p>
<p>​		第一棵树正在处于<strong>平衡状态</strong>，此时的最糟的运行时间为 O(log n)。第二棵树处于<strong>非平衡状态</strong>，此时的最遭的运行时间为 O(n)，仿佛整棵树马上就要向左倒下来。由于树与链表相似，都不支持随机访问，二叉查找树处于平衡状态时，平均访问时间为 O(log n)。</p>
<p>下面给出一下数组和二叉查找树的性能。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">数组</th>
<th style="text-align:center">二叉查找树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查找</td>
<td style="text-align:center">O(log n)</td>
<td style="text-align:center">O(log n)</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(log n)</td>
</tr>
<tr>
<td style="text-align:center">删除</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(log n)</td>
</tr>
</tbody>
</table>
<p>​		此外，还有几种特殊的二叉查找树，如 <strong>B树</strong>、<strong>红黑树</strong>、<strong>堆</strong>、<strong>伸展树</strong> 等，当然这就是另一个故事了。</p>
<h3 id="反向索引">反向索引</h3>
<p>这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E4%BB%AC.jpg" alt></p>
<p>我们根据这些内容船舰一个散列表。</p>
<p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E6%95%A3%E5%88%97%E8%A1%A8.jpg" alt></p>
<p>​		这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜索 hi，在这种情况下，搜索引擎需要检查哪些页面包含 hi。<br>
  搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜索 there。你知道，页面 A 和 C 包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散列表，将单词映射到包含它的页面。这种数据结构被称为<strong>反向索引（inverted index）</strong>，常用于创建搜索引擎。如果对搜索感兴趣，从反向索引着手研究是不错的选择。</p>
<h3 id="傅里叶变换">傅里叶变换</h3>
<p>  绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained 是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。<br>
  这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理。<br>
  数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。<br>
  使用傅里叶变换可创建类似于 Shazam 这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高。</p>
<p><strong>接下来的三个主题都与可扩展性和海量数据处理相关</strong>。</p>
<h3 id="并行算法">并行算法</h3>
<p>  我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们能够在多个内核中并行地执行！<br>
  来看一个简单的例子。在最佳情况下，排序算法的速度大致为 O(n log n)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)。对数组进行排序时，快速排序的并行版本所需的时间为 O(n)。<br>
  并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。</p>
<ul>
<li><strong>并行性管理开销</strong>。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。</li>
<li><strong>负载均衡</strong>。假设你需要完成 10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么 50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</li>
</ul>
<h3 id="MapReduce">MapReduce</h3>
<p>  有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce 是一种流行的分布式算法，你可通过流行的开源工具 Apache Hadoop 来使用它。</p>
<h4 id="分布式算法为何很有用">分布式算法为何很有用</h4>
<p>  假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过Hadoop来使用MapReduce！<br>
  又假设你需要处理一个很长的清单，其中包含 100万个职位，而每个职位处理起来需要 10秒。如果使用一台计算机来处理，将耗时数月！如果使用 100台计算机来处理，可能几天就能完工。<br>
  分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：**映射（map）<strong>函数和</strong>归并（reduce）**函数。MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用 MapReduce 只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。</p>
<h2 id="布隆过滤器和HyperLogLog">布隆过滤器和HyperLogLog</h2>
<p>​		在假设你管理着 Google，要<strong>避免</strong>将用户重定向到恶意网站。你有一个清单，其中记录了恶意网站的 URL。你需要确定要将用户重定向到的 URL <strong>是否在这个清单</strong>中。这些一类型的问题，通常都要涉及庞大的集合。给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用<strong>散列表</strong>。例如，Google可能有一个庞大的散列表，其中的<strong>键是已搜集的网页</strong>。初始状态时，所有键所对应的值都是“False”。第一次判断 A 网页是否在该集合时，只需或许 A 网页所对应的值即可。随后发现不在这个集合，同时 A 的确是个恶意网页时，就将 “False” 改为 “True”，之后系统再次判断 A 网页是否是恶意网页时，可以先获取其对应的的值即可。散列表的平均查找时间为 O(1)，即查找时间是固定的，这应该是个非常乐观的时间复杂度了。不过 Google 需要建立数万亿个网页的索引，因此这个散列表非常大，需要<strong>占用大量的存储空间</strong>。面临海量数据，我们可以选择非常有创造性的方案——<strong>布隆过滤器</strong>，来解决这种问题。</p>
<h3 id="布隆过滤器">布隆过滤器</h3>
<p>​		布隆过滤器提供了解决之道。布隆过滤器是一种<strong>概率型数据结构</strong>，它提供的答案有可能不对，但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。具体表现为如下。</p>
<ol>
<li>可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。</li>
<li>不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。</li>
</ol>
<p>​		布隆过滤器的优点在于<strong>占用的存储空间很少</strong>。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况。</p>
<h3 id="HyperLogLog">HyperLogLog</h3>
<p>​		HyperLogLog是一种类似于布隆过滤器的算法。HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<strong>面临海量数据且只要求答案八九不离十时，完全可以考虑使用概率型算法</strong>。</p>
<p><strong>接下来的两个话题都与加密算法有关</strong>。</p>
<h2 id="SHA算法">SHA算法</h2>
<p>​		之前介绍的散列函数都是将<strong>键</strong>直接映射到内存地址上。而另一种散列函数，安全散列算法（secure hash algorithm，SHA）函数，则是将<strong>字符串类型</strong>的<strong>键</strong>直接映射到一个较短字符串上。比如 “hello” 这个字符串同过SHA256 加密后的结果为<code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code></p>
<p>下面简述安全散列算法的<strong>安全</strong>体现在哪里。</p>
<ol>
<li>这个散列函数不会产生冲突，因此不会出现因为明明输错密码还能够成功登录的情况。</li>
<li>这个散列函数没有反函数，意味着不能直接反破译出密码，因此密码校验都是用 SHA 加密结果进行比对。</li>
<li>就算原字符串只改变了一个字符，最终的 SHA 结果也会截然不同。因此攻击者无法通过比较散列值是否类似来破解密码。这时就称这种散列函数对<strong>全部敏感</strong>。
<ol>
<li>“hellow” SHA256 加密结果为<code>d0bc381952d0827f36467818a9560eb5eb6fda8a64a422aa21fcda3f2263e8b4</code></li>
<li>“hella” SHA256 加密结果为<code>70de66401b1399d79b843521ee726dcec1e9a8cb5708ec1520f1f3bb4b1dd984</code></li>
<li>“hell” SHA256 加密结果为 <code>0ebdc3317b75839f643387d783535adc360ca01f33c75f7c1e7373adcd675c0b</code></li>
</ol>
</li>
</ol>
<p>SHA除了核对密码外，还可以<strong>判断文件是否为同一文件</strong>，即 将两个文件的 SHA 值计算出来进行比对即可。</p>
<p>​		SHA实际上是一系列算法：SHA-0 , SHA-1 , SHA-2 和 SHA-3。其中，SHA-0 和 SHA-1 已被发现存在一些缺陷。如果你要用SHA算法来计算密码的散列值，请使用 SHA-2 或 SHA-3。当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。</p>
<h3 id="Simhash">Simhash</h3>
<p>​		simhash 是对局部敏感的散列函数，表现为如果你对字符串做细微的修改，Simhash 生成的散列值也只存在细微的差别。这时，你可以通过比较散列值来判断两个字符串的相似程度。</p>
<ul>
<li>Google 使用 Simhash 来判断网页是否已搜集；</li>
<li>老师可以使用 Simhash 来判断学生的论文是否是从网上抄的。</li>
</ul>
<h2 id="Diffie-Hellman-密钥交换">Diffie-Hellman 密钥交换</h2>
<p>​		简单的加密算法就不再赘述了，因为加密程度比较低，因此非常容易暴力破解出来。Diffile-Hellman 算法，简称 DH 算法。它有以下两个优点。</p>
<ol>
<li>双方无需知道加密算法。他们不必会面协商要使用的加密算法。</li>
<li>要破解加密的消息比登天还难。</li>
</ol>
<p>​		DH 算法加密时会使用到两种密钥：<strong>公钥和私钥</strong>。顾名思义，公钥就是公开使用的密钥，被第三者获取了也无所谓。而私钥，则是最终解密的关键。具体 DH 算法是如何执行的，可以去 B 站搜索 <strong>av73112181</strong>，这个视频中用类比的方式比较直观地演示了密钥交换过程，个人也觉得既优雅又不难理解。DH 算法是算法加密的先驱者，它的后辈 <strong>RSA 算法</strong>依然在被广泛使用，当然这就是另一个故事了。</p>
<h2 id="线性规划">线性规划</h2>
<p>​		但愿读者还能想起来自己高中还确实学过<strong>线性规划</strong>这么个东西。线性规划就是为了不断优化，最终达到最优解的工具，这与算法中优化的思想不谋而合，因此线性规划本质上也是可以算作是算法。所有的<strong>图算法</strong>都可使用线性规划来实现。线性规划是一个宽泛得多的<strong>框架</strong>，而图问题只是其中的一个子集！因此把如此牛掰的算法放最后讲也不是没有道理的。线性规划使用Simplex算法，不过这个算法很复杂，详细介绍就又称另一个故事了。</p>
<h1 id="结语">结语</h1>
<p>​		希望你可以在这个饱受争议的领域中，走出那个连曾经那个自己都不敢想象的路途，浮躁的情绪沉淀下来或成为你的决心。希望我可以一直娓娓道来曾经我还未讲述的故事，当然这就是另一个故事了。</p>

      
    </div>
    
    
    

    <div>
       
        <div>
    
        <div style="text-align:center;color:#bfbfbf;font-size:16px;"> 
            <span>-------- おやおや? </span> 
            <i class="fa fa-coffee"></i> 
            <span> 侘寂 --------</span> 
        </div> 
    
</div> 
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/" rel="next" title="从零开始的 Java 语法学习">
                <i class="fa fa-chevron-left"></i> 从零开始的 Java 语法学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="齿维" />
              </a>
            
              <p class="site-author-name" itemprop="name">齿维</p>
              <p class="site-description motion-element" itemprop="description">辜负期盼，是罪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            
            
          </nav>
          
          

          

          
          

          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#何为算法"><span class="nav-text">何为算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#大-O-表示法"><span class="nav-text">大 O 表示法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组与链表"><span class="nav-text">数组与链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分治"><span class="nav-text">分治</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程"><span class="nav-text">函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表"><span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表的应用"><span class="nav-text">散列表的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广度优先搜索"><span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何为广度优先搜索"><span class="nav-text">何为广度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现图"><span class="nav-text">实现图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现算法"><span class="nav-text">实现算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#狄克斯特拉算法"><span class="nav-text">狄克斯特拉算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于实现"><span class="nav-text">关于实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪心算法"><span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NP完全问题模型—集合覆盖问题"><span class="nav-text">NP完全问题模型—集合覆盖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NP完全问题模型—旅行商问题"><span class="nav-text">NP完全问题模型—旅行商问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何识别NP完全问题"><span class="nav-text">如何识别NP完全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#描述"><span class="nav-text">描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#揭晓"><span class="nav-text">揭晓</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划问题"><span class="nav-text">动态规划问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划的认知"><span class="nav-text">动态规划的认知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划问题建模"><span class="nav-text">动态规划问题建模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#所谓费曼算法"><span class="nav-text">所谓费曼算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旅游行程最优化"><span class="nav-text">旅游行程最优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子串"><span class="nav-text">最长公共子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列"><span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划的实际应用"><span class="nav-text">动态规划的实际应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K最近邻算法"><span class="nav-text">K最近邻算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KNN算法"><span class="nav-text">KNN算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特征抽取"><span class="nav-text">特征抽取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回归"><span class="nav-text">回归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#余弦相似度"><span class="nav-text">余弦相似度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述机器学习"><span class="nav-text">简述机器学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OCR"><span class="nav-text">OCR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建垃圾邮件过滤器"><span class="nav-text">创建垃圾邮件过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预测股票市场"><span class="nav-text">预测股票市场</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后再介绍十种数据结构和算法"><span class="nav-text">最后再介绍十种数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反向索引"><span class="nav-text">反向索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#傅里叶变换"><span class="nav-text">傅里叶变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行算法"><span class="nav-text">并行算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce"><span class="nav-text">MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式算法为何很有用"><span class="nav-text">分布式算法为何很有用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布隆过滤器和HyperLogLog"><span class="nav-text">布隆过滤器和HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布隆过滤器"><span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-text">HyperLogLog</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHA算法"><span class="nav-text">SHA算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Simhash"><span class="nav-text">Simhash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Diffie-Hellman-密钥交换"><span class="nav-text">Diffie-Hellman 密钥交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性规划"><span class="nav-text">线性规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结语"><span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

      
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
            <h3 class="widget-title">Tag Cloud</h3>
            <div id="myCanvasContainer" class="widget tagcloud">
                <canvas width="250" height="250" id="resCanvas" style="width=100%">
                    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E5%9D%91Java/" rel="tag">入坑Java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">1</span></li></ul>
                </canvas>
            </div>
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script
  async
  src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"
></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">齿维</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
-->




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位友人，
    </span>
  

  
    <span class="site-uv">
     历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="[object Object]"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: '3aYMDSnH84YevyiTCRJFpTu8-gzGzoHsz',
        appKey: 'nmv3DaWhaNkdjAbEg8jfVIbN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3aYMDSnH84YevyiTCRJFpTu8-gzGzoHsz", "nmv3DaWhaNkdjAbEg8jfVIbN");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
