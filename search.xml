<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从一开始的 Java 语法学习②</title>
      <link href="/2020/02/18/%E4%BB%8E%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%91%A1/"/>
      <url>/2020/02/18/%E4%BB%8E%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%91%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>研究了 Java 中的一些基本特性及语法，诸如 Java 中对象的初始化、等等</strong><br>v1.0.20200225</p><a id="more"></a><h1 id="阅前须知">阅前须知</h1><p>  这是一个从一开始学习 Java 的文章，没有过多的关于语法方面的内容，非快餐向（欲速则不达），仅供参考。本篇文章需要读者对面向对象有个基本的概念的认知。本篇文章所参考的书籍为&quot;OnJava8&quot;，这是《Java 编程思想(第四版)》的作者在 2016年基于 <strong>JDK 1.8</strong> 所新编的 Java 学习教材，因此又被称为《Java 编程思想(第五版)》。我猜测点开这篇文章的读者一般是，抱着入门 Java 的心态学习 OnJava8 这本书，但同时希望有人已经写过类似于学习笔记一样的博文来加深理解，或者是书中的哪一块有点弄不太懂，希望有个更清楚的解释。这样的人我相信这个&quot;读书笔记&quot;应该是非常适合你的。不过还是要提一点的是，除非是老手(不过老手也不会看这篇博文就是了)，一定要在书中至少阅读一遍你想要学的章节，然后再来考虑看不看这篇文章，这个博文只能是起到辅助作用，多读几遍书远比看几百通博文的效率来的高多了，免得浪费更多的时间。<br>  之所以选用这个系列主要是因为久仰大名了，《Java 编程思想(第四版)》甚至被有些人索性称作是 Java 书籍中的圣经，那么对初学者有这么一本权威性的书籍固然是好的，但问题是零基础小白想吃透这本书难度还是不小的。鉴于本人也确实没什么经验，因此在读这本书的时候，我打算把我认为比较基础性、启发性的内容用自己的话提出来，省略掉书中繁琐的例子，整体偏理论风一点，实践部分较少，我知道这对一门工科的学习是不应该的，所以看的同时还要多敲敲代码，找一个上手简单的项目练练手是最好的。所以这个博文的标题叫从一开始而不是从零开始，因为不管是 OnJava8 的读者也好，这篇博文的读者也罢都确实需要一定量的底子，说白了就是计算机素养。<br>  写博文时我都会<strong>每天坚持一定增量交付</strong>。目前的我确实不能完全 hold 住本书，但是后期每提升一个阶段我会尝试用更高的角度再来看看这篇博文，我能看得出来的有能改进的地方我就会尽力修改掉（点进文章之前标题下面会有类似于版本号的数字就是我版本迭代的标识) 。<br>  文中会经常出现<strong>标黑</strong>和<code>高亮</code>的词语或短句，前者主要是一些计算机术语或是想要表示强调，后者则是英文的术语或者符号以及表示强调时使用。<br>  以下是原书作者在&quot;OnJava8&quot;开头整本书的简介，更多内容请参考<a href="https://lingcoder.github.io/OnJava8/#/sidebar" target="_blank" rel="noopener">原书在线中文译版</a>。</p><blockquote><p>  Java 本身是门派生语言，是在 C++ 基础上新增和删除了一些功能。其中最核心的变化就是加入了“虚拟机”和“垃圾回收机制”，此外，Java 还在其他方面推动了行业发展。例如，现在绝大多数编程语言都支持文档注释语法和HTML 文档生成工具。<br>  把一切事物都抽象成对象不仅是一项不必要的负担，同时还会招致许多设计朝着不好的方向发展。但“对象”的概念依然有其闪光点。固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；相反，完全逃避“对象”的概念似乎同样太过苛刻。<br>  编程语言不是神造物，因此难免会有设计缺陷，即便是当下普及度最广的 Java，学习时我们应该也要带着<strong>批判性的思维</strong>去学习。正因为 Java 是<strong>严格向后兼容</strong>的，因此有些设计缺陷到现在还有在保留，如果不去正式这些错误，而反而去包庇则是相当不可取的行为。<br>  Java 语言曾规划设计的许多功能并未按照承诺兑现。本书中，我将尝试解释这些原因，力争让读者知晓这些功能，并明白为什么这些功能最终并不适用。这无关 Java 是一种好语言或者坏语言，一旦你了解了该语言的缺陷和局限性，你就能够：</p><ol><li>明白有些功能特性为什么会被“废弃”；</li><li>熟悉语言边界，更好地设计和编码。</li></ol><p>阅读本书需要读者对编程有基本的了解:</p><ul><li>程序是一系列“陈述（语句、代码）”构成；</li><li>子程序、方法、宏的概念；</li><li>控制语句（如 if），循环结构（如 while）。</li></ul><p>  甲骨文公司已经提供了免费的标准 JDK 文档。除非有必要，否则本书中将不再赘述 API 相关的使用细节。使用浏览器来即时搜索最新最全的 JDK 文档好过翻阅本书来查找。只有在需要补充特定的示例时，我才会提供有关的额外描述。</p></blockquote><p>  由于英文原版书的页数已经超过 3k page，因此我不打算把我所有内容全部写在一篇博文上，会分成若干篇进行阶段式总结，并且每篇文章的最后都会对这一阶段抽象出来做一个高度总结。工科的学习除了理论知识外还强调自己亲自落地实践，因此还后期阶段还可能会在 GitHub 上扒几个小练手的项目，到时候在针对那个项目再开一篇博文。顺带一提，之后会针对原书的第一章，即对象导论中的内容单开一篇博文，当然这都是很后面的事情了。</p><h1 id="初始化和清理">初始化和清理</h1><p>  对象的一生必须经历两个阶段，<strong>初始化</strong>和<strong>清理</strong>。Java 的<strong>垃圾收集器(Garbage Collector, GC)</strong> 会自动地回收不再被使用的对象的资源，非常有效地解决了 C/C++ 中程序耗光了所有地资源的情况。而在初始化这一块，C 的程序员往往经常忘记初始化变量从而出现非常多的 Bug。C++ 提供的方案很好地解决了这个习惯性地问题——构造器，也叫构造方法，是类中的一个特殊的方法，特殊在每创建一个对象时，这个方法都会被自动隐式调用一次，<strong>保证新建出来的对象的初始化</strong>，Java 觉得 C++ 的方案非常不错，于是就直接照搬过来了。<br>  我们希望类创建下来的同时类的构造器就能确定下来，也就是说两者应该是以某种形式绑定在一起的，这样编译时编译器也方便根据类名就能找到构造器。于是 Java 要求，构造器名称必须与所属类型相同。并且，构造器没有返回值，连空值都不返回，这是有别于一般的方法的。<!--如果Tree(int) 是唯一的构造器，那么编译器就不允许你以其他任何方式创建Tree 类型的对象。--></p><h2 id="方法重载">方法重载</h2><p>  可能方法重载的跟我们的马上要讲的构造器没有太大的关系，但方法重载的思想却可以很好地解释构造器存在的一部分理由。方法重载指的是不同方法的方法名<strong>相同</strong>，但参数列表<strong>不同</strong>，与方法体和返回值无关的现象。<br>  在我们日常生活所使用的语言中，一个词可以有非常多的语义，这时就可以说这个词被<strong>重载</strong>了。当语义之间的差异比较小时，更能体现出重载的意义，因为重载的程度越高就显得这个词可以干更多的事。很明显这对构造器来说重载是极其有意义的，Java 也允许一个类里面有多个构造器，这样我们就可以用不同的方法去创建同一个类型的对象了，特别是当这些对象十分相似但又确实不同的时候。<br>  重载不仅对构造器有意义，它对任何方法都很有意义。最终的意义就在于增强了代码的可复用性：明明是同一个类型，实例化时通过调用不同的构造器，使每个对象都有自己独有的特性。</p><h2 id="构造器">构造器</h2><p>  构造器形式上跟普通的方法没什么区别，但它的目的并不仅仅是执行它的方法体，而是为了初始化对象，就像是一个信号枪，一旦调用了这个构造器，就意味着有一个新的对象将要产生。并且这个&quot;特殊的&quot;方法没有返回值，就连空值也不返回，因此也不允许方法名前加 <code>void</code> 关键字。我看了有些人的博文会意淫说构造器会返回已经初始化完成的对象。反正我这里是全部按照 OnJava8 中的说法来的，最多也就是 <code>new</code> 这个关键字最后提供当前对象的引用而已。</p><p>在了解初始化对象的过程时，你需要补充这两个前置知识：</p><ol><li>即使没有显式地使用 <code>static</code> 关键字，构造器实际上也是静态方法。</li><li>当首次实例化对象或是首次访问类的静态方法或属性时，Java 解释器必须在类路径中查找以定位类的 <code>.class</code> 文件。</li></ol><p>如果现在对第二条有点懵，其实完全不要紧，现在只知道有这么个东西就行了，之后会慢慢涉及到。<br>实例化必须依次经历下面几个步骤：</p><ol start="2"><li>调用<strong>指定</strong>构造器；</li><li>根据指定构造器， Java 解释器在类路径中定位指定类的 <code>.class</code> 文件；</li><li>加载创建完指定类的 class 对象；</li><li>执行静态初始化动作；</li><li><code>new</code> 关键字在内存中分配空间；</li><li>执行非静态初始化动作；</li><li>执行指定构造器的方法体。</li></ol><p>你应该会对第 4 条有疑惑，因为我中间省略掉了很多步骤：</p><ol><li>类被加载后，普通方法加载到方法区，静态方法和静态字段加载到方法区中的静态区；</li><li>静态字段进行默认初始化；</li><li>静态字段进行显式初始化；</li><li>执行静态代码块中的内容。</li></ol><p>此外，第 7 步与第 4 步内部的操作类似：</p><ol><li>非静态字段进行默认初始化；</li><li>非静态字段进行显式初始化；</li><li>执行非静态代码块中的内容。</li></ol><p>  从上面初始化对象的几个步骤来看，好像在第 3 步中类的对象就已经产生了，只是还没有初始化完成。此时只能是通过 <code>this</code> 关键字内部进行访问，直到构造体的方法体执行结束后外部程序才能真正访问这个对象。对象一旦创建好之后，编译器就不允许让我们调用对象的构造器了，也就是说，之后只能调用对象的除构造器以外的方法。<br>  类中没有构造器时，编译器会说“你一定需要构造器，那么让我为你隐式创建一个吧”，于是初始化对象时我们就会调用的这个没有方法体的无参构造器。但是如果类中有构造器，编译器会说“你已经写了构造器了，所以你肯定知道你自己在做什么，如果你没有重载无参构造器，说明你本来就不需要”。<br>  现在还没有涉及到更为复杂的构造器，到后面的章节，特别是当通过组合或继承创建新类的时，构造器可以变得更加地多样。</p><h2 id="this-关键字">this 关键字</h2><p>  <code>this</code> 生成了当前对象的引用，你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用该类中其它的方法，不要使用 <code>this</code>，直接调用即可，因为 <code>this</code> 会自动地应用于其他方法上了。<code>this</code> 关键字只用在一些必须显式使用当前对象引用的特殊场合，比如在 <code>return</code>  语句中返回对当前对象的引用，<code>this</code> 关键字向类内其它方法传递当前对象，成员变量与局部变量名称冲突时。<br>  不过在众多应用中，最有用的应该是通过 <code>this</code> 关键字实现在构造器中调用构造器。为什么可以这么做呢？想要构造器调用构造器只能是实例化的第 7 步才有机会，即执行指定构造器的方法体，因为没有实例化完全就意味着还有调用对象的构造器的机会，这个时候再用 <code>this</code> 关键字它不香吗。<br>  构造器调用构造器的目的可以简单地理解为只是为了要执行第二个构造器的方法，这部分背后底层的逻辑可以先放一放，就记住可以通过 <code>this</code> 关键字在构造器中调用构造器，这样做的好处是使对象更能应对一些复杂的情况。<br>  那可不可以通过除构造器以外的方法去调用构造器呢？不可以，或者说应该是不可能的。创建好一个对象是调用其它一般方法的前提，但一旦对象初始化完成就无法继续用任何方式调用对象的构造器了，因此用其它方法去调用构造器本身事实上就是个矛盾。</p><h3 id="static-与-this">static 与 this</h3><p>  static 本身是就已经脱离了对象一样的存在，与对象的存在与否无关，只服务于类而存在着，固然也就不存在在 static 方法中使用 this 关键字的说法。因此尽管可以在非静态方法中调用静态方法，可就是不能在静态方法中调用非静态方法。从语义上来看这就像是全局方法一样，一点也不 “OOP 风格”。如果你的代码中出现了非常多的 static 方法，你就应该重新考虑你对这个类的设计了。当然，这并不是抵制使用 static 的意思，因此 static 的概念确实很实用，很多时候我们都要用到它。<br>  如果觉得上面的构造器和 this 关键字部分差不多了（重点是构造器的那部分），试着不依靠调试在大脑中跑这一段代码，看看输出结果和你想的是否一致，如果不一致就在多花点时间慢慢理解上面的内容，或者把代码复制到你的 IDE 里一点点调试一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Bowl("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"f1("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    System.out.println(<span class="string">"Table()"</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"f2("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">  Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    System.out.println(<span class="string">"Cupboard()"</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"f3("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"main creating new Cupboard()"</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    System.out.println(<span class="string">"main creating new Cupboard()"</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table()</span></span><br><span class="line"><span class="comment">f1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">main creating new Cupboard()</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">main creating new Cupboard()</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupboard()</span></span><br><span class="line"><span class="comment">f1(2)</span></span><br><span class="line"><span class="comment">f2(1)</span></span><br><span class="line"><span class="comment">f3(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  由于方法调用栈的关系，倒着读代码有助于跟着编译器编译代码时的步骤，知晓数据的流向。当然，最简单的办法还是用 IDE 的调试工具跟着走几遍就好，只是倒着读代码也未尝不是个好的习惯呢。</p><h2 id="垃圾回收器">垃圾回收器</h2><p>  抱歉，尽管书中已经用了比较多的篇幅去讲解内存中的对象清理问题。但是由于牵扯到的新知识比较多，就怕去了解又要牵动非常多的知识，诸如 <code>finalize()</code> ，<code>析构器</code>，<code>JVM</code>，<code>停止-复制</code>，<code>标记-清扫</code>，<code>自适应</code>，<code>页面调度</code>，<code>JIT</code>，<code>惰性评估</code>，短时间理清确实有点困难。我打算把这些底层的东西先放一放，之后如果是时候深入了解的时候我再把这个坑填上。我知道这可能显得有些不负责任，但追求整体学习效率为优先。</p><h2 id="静态段与非静态段">静态段与非静态段</h2><p>  在学习静态段和非静态段之前，你发现在方法以外的地方，是不允许再调用函数的，这时你就可以把调用方法的操作写在类的静态段或非静态段里面。形式上，有无 <code>static</code> 关键字是静态段和非静态段唯一的区别。两者形式上的共同点当然就是可以在 <code>{}</code> 里写一些语句什么的。</p><p>静态段和非静态段的作用一共有两点：</p><ol><li>在方法外调用方法；</li><li>改变初始化的优先级。</li></ol><h2 id="初始化数组">初始化数组</h2><p>  数组是引用数据类型，数组引用的声明有两种：<code>int a[]</code> 和 <code>int[] a</code> 。两种并无本质区别，但更为推荐后者的书写格式。此外，任何数组对象都有一个固定成员属性：<code>length</code>，我们可以利用它来动态查询数组对象的长度或者说<strong>大小</strong>。<br>  数组对象声明完引用后我们需要为数组对象分配空间，也就是初始化数组。在 Java 中大可分为两种初始化数组对象的动作：一种<strong>静态初始</strong>和两种<strong>动态初始</strong>。</p><h3 id="静态初始">静态初始</h3><p>  我们知道 new 关键字只是为了在堆内存中开辟空间，便于之后初始化动作的进行。但 Java 为数组的初始化提供了一种特殊的方法进行初始化，之所以特殊是因为不需要用到关键字 new 就可以为数组对象分配空间。就像这样 <code>int[] a = {0,1,2,3,4}</code> ，这也被称为静态数组创建。</p><h3 id="动态初始">动态初始</h3><p>  相反的，我们还有动态数组创建：<code>integer[] a = new integer[num]</code> 。这样你就创建了一个<strong>引用类型</strong>数组，数组索引为对象的引用。其中 num 是个整型，用来指定数组对象的大小。这种初始化的特点是你可以先为数组元素设置默认值，之后再赋值。很明显，这个 new 就是为每个默认对象开辟空间用的。值得一提的是，针对基本类型数组，Java 还提供了 <code>int[] a = new int[num]</code> 这种方式。可能有人不太喜欢这样的用法，因为基本类型明明不是对象却还能用 new 关键字，但由于有自动拆装箱机制的存在，与引用类型数组之间的区别并不大。<br>  还有一种初始化方式与上面的方式类似，也是动态创建数组： <code>integer[] a = new integer[]{}</code>。唯一的区别是省略掉了为引用赋默认对象的过程，初始化安全性更高，因为直接使用没有初始化的对象可能会报错。<br>  静态初始尽管很有用，但它当且只能用于数组定义处初始化，比较地受限。而动态初始可以用在代码的任何地方，甚至用在方法的内部，尤其是推荐动态初始动作的第二种方式。</p><h3 id="按值传递-or-按引用传递">按值传递 or 按引用传递</h3><p>  在查找有关数组的知识的时候经常会看见按值传递和按引用传递这两个概念，并且有的人坚持 “Java 里面都只按值传递” 的观点，另一些人则坚持 “Java 既有按值传递也有按引用传递” 的观点。于是在众多答案中，挑了一个我觉得靠谱的答案：</p><ol><li>“在 Java 里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递；</li><li>在 Java 里面只有基本类型和按照下面这种定义方式的 String 是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”;</li></ol><p>所以我觉得硬要说 Java 里面参数传递都是按值传递也可以，不过从结果上来看说跟没说一样，没什么意义。</p><h3 id="可变参数列表">可变参数列表</h3><p>  之前我们方法的形参列表都是非可变参数列表，也就是说一旦遇到 <code>class[] args</code> 这样的形式，就意味着你<strong>必须</strong>传入一个 class 类型的数组。<br>  现在你可以通过在形参列表中添加 <code>class... args</code> 这样的形式来一次性传入<strong>任意多个</strong>参数或者<strong>一个都不</strong>传。它的含义是，当你传入多个参数时 Java 会自动将众多参数组成一个数组，最终把这个数组传进去。你若是无参调用这个方法，Java 会视为你在尝试将一个大小为零的数组传进这个方法中。由于可变参数的参数数量可以为零，因此有可选的<strong>尾随参数</strong>的情况下，这种可变参数就显得非常有用了。<br>  另外，如果 <code>class... args</code> 里面传出的不是一堆参数而是一个 class 类型的数组时，Java 会直接当作已经当作已经处理好的数组接受。<br>  值得一提的是，可变参数一定要设置为参数列表的最后一个参数。之所以 Java 会这么设计，是为了避免某些情况下因参数数量引起的的逻辑矛盾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : args)</span><br><span class="line">            System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray(<span class="keyword">new</span> Integer[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;);</span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">47 3.14 11.11 </span></span><br><span class="line"><span class="comment">47 3.14 11.11 </span></span><br><span class="line"><span class="comment">one two three </span></span><br><span class="line"><span class="comment">A@1b6d3586 A@4554617c A@74a14482 </span></span><br><span class="line"><span class="comment">1 2 3 4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  如果没有可变参数的帮忙，我们要在每个需要传入数组的位置<strong>显式动态初始化数组对象</strong>。比如上面的代码中 <code>printArray(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);</code> 就要改成 <code>printArray(new String[]{&quot;one&quot;,&quot;two&quot;,&quot;three&quot;});</code>。此外，可变参数也是也是兼容类型转换和自动拆装箱的，这也明显地提高了我们编程的效率。</p><h2 id="枚举类型">枚举类型</h2><p>  倘若你需要一个有序的集合来存储你的值，Java 提供 <code>enum</code> 关键字来定义枚举类型来达成你的目的。枚举类型也是类类型，因此也能实例化产生对象，是对象就有自己的属性和方法。更重要的是，你可以在枚举类型里面定义一些<strong>静态</strong>常量值。这些常量值组成的有序集合会保持高内聚低耦合的状态，使用时更加放心。<br>  注意常量的命名，都是大写字母，由多个单词组成的常量中间需要有 <code>_</code> 连接。下面就是一个简单的枚举类型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  枚举类型天生和 <code>switch</code> 语句搭配，因为 switch 也是要求从有限的可能值集合中选取。就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"This burrito is "</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:    System.out.println(</span><br><span class="line">                    <span class="string">"not spicy at all."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM: System.out.println(<span class="string">"a little hot."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:     System.out.println(<span class="string">"maybe too hot."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">                greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">                jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">This burrito is a little hot.</span></span><br><span class="line"><span class="comment">This burrito is maybe too hot.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  到这里原书也是点到为止，但倒数第四章整章都在讲枚举类型，因此关于枚举类型更多的内容到那时会再详细讲解。</p><h1 id="封装">封装</h1><p>  如果你对书中&quot;封装&quot;这一章的开头就比较地晕的话，建议先看看这个关于<a href="https://www.jianshu.com/p/85c1f10e5323" target="_blank" rel="noopener">包和 Java 命名空间</a>以及 <a href="https://blog.csdn.net/azhangyi188/article/details/80214403" target="_blank" rel="noopener">Java类库及API</a> 的博文，说明还是非常到位的。不过需要勘误的是，第一篇文章提到了子包这个概念，但事实上 Java 是并没有子包的，所有包都是并列独立的，因此你也可以说包是<strong>全局的</strong>。比如 <code>org.dominoo.action</code> 和 <code>org.dominoo.action.asl</code> 之间绝对没有包与子包的关系，它们都是各自独立的包，各自拥有自己的 <code>class/interface</code> 的集合，仅仅靠路径是说明不了什么问题的。</p><h2 id="包">包</h2><p>  一个 Java 源代码文件(<code>.java</code> 文件) 被称为编译单元，要求这个编译单元中最多只能有一个 <code>public</code> 类，并且要求这个类与文件名完全相同。此外，这个编译单元内可以有任意多个非 <code>public</code> 类，但由于它们是非 <code>public</code> 权限，所以无法被外界访问到。<br>  当编译一个 <code>.java</code> 文件时，<code>.java</code> 文件中的每个类都会输出一个名称与类名相同的 <code>.class</code> 文件。因此，少量的 <code>.java</code> 文件编译后可能会得到大量的 <code>.class</code> 文件。<br>  此外，我们还可以将这些 <code>.class</code> 文件通过 jar 文档生成器打包压缩成一个  <strong>Java 文档文件(JAR)</strong>，之后解释器可以查找、加载并解释这些 JAR 文件。当然，你的软件如果像开源的的话，可以把 <code>.java</code> 文件一起分开打包成 JAR 包。<br>  类库是一组类文件，每个文件都有一个构件，也就是 <code>public</code> 类。如果把这些构件集中在一起，就需要使用关键字 <code>package</code>。下面就依此详细展开。<br>  因为人类可用的单词数太少，类库中的构件名存在潜在冲突，引起了一场&quot;命名危机&quot;，于是人们就引入了命名空间这个概念。之后人们想到既然我们可以给类取名字，那我们还可以再给类库取个名字，这样的话我们就不是可以间接地给类库里面的类的名字增加一个前缀，从而间少冲突的机会吗。但类库本身是个比较抽象的概念，直接动它不太方便，于是就引入了包，给包命名。但我们还不满足，因为实际在复杂的项目，只要产生冲突就是个非常可怕的事情，于是又想到了用小写域名的逆序给包命名，来保障包名的<strong>唯一性</strong>。<br>  用域名这一点有些人认为是业界约定俗成，并不是强制规定，这主要是因为域名具有唯一性来保障包名的唯一性。至于为什么要用域名的逆序这里有一个观点我觉得是比较合理的。假设要在电脑里找到某个目录下的文件时，我们总是要从大路径去查找定位小路径，包中的类文件也是如此。假定 <code>chiwei.java.com</code> 这样的域名，在一定要使用域名进行包的命名的前提下，正序域名时你若把文件存在 <code>com</code> 目录下，你就需要先从 <code>chiwei/java</code>  目录找 <code>com</code>，这就显得非常没有必要且意义不明，因为正常来说 <code>com</code> 的范围因该是要比 java 大的，而 <code>java</code> 的范围则应该是要比 <code>chiwei</code> 大的。<br>  包其实代表的是一个路径，这个路径的下面有相关类的集合。你也可以把包理解为对命名空间的一种<strong>建模</strong>。类库开发者需要将类库各个组件捆绑内聚到一个类库单元中。而 Java 中可以通过在组件中添加 <code>package</code> 关键字使得各个类置于同一包下，使我们更好地访问并管理类库。<br>  关于解释器就在目录中查找与你所创建的类名称相关的 <code>.class</code> 文件的过程原书已经说地非常清楚了，简言之就是将环境变量 CLASSPATH 和通过 package 获取的相对路径合成一个绝对路径用来查找 <code>.class</code> 文件。不得不承认，有些繁杂的过程都在 IDE 的加持下变得极其方便，这也是一部分人不推荐新手刚开始就用 IDE 学习的原因，因为它会掩盖一部分操作，使得初学者不会去注意那部分的内容，所以还是有必要去特意去学一下的。<strong>现在具备了以上知识，终于可以创建属于自己的工具库来减少重复的程序代码了</strong>。</p><h2 id="访问权限修饰符">访问权限修饰符</h2><p>  <code>public</code> , <code>private</code> , <code>protected</code> , <code>friendly</code> 中每个访问权限所设置的&quot;层面&quot;都不一样。public 是全局的，private 只能是自己访问自己，friendly 则是严格意义上不允许包外类访问，protected 则是在 friendly 的基础上多了一点东西，下面有讲到。值得一提的是，一个编译单元的内的<strong>所有类</strong>均可视为包内类。</p><table><thead><tr><th style="text-align:center">访问权限修饰符/访问者</th><th style="text-align:center">本类</th><th style="text-align:center">包内类</th><th style="text-align:center">包外类</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">friendly/默认/无</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>  之所以没有把 <code>protected</code> 放到这上面是因为它比较特殊。不考虑继承时 protect 和 friendly 是没有区别的。考虑倒了继承，设计师才会在 friendly 的基础上做了增量变化。子类可以<strong>间接地</strong>访问父类被 protected 的方法，这是由于继承时，子类可以获得符类方法的地址并将其存储在自己的方法区中，当然重写父类 protected 方法时就直接访问重写后的方法。如果学有余力，你可试着看看<a href="https://blog.csdn.net/dawn_after_dark/article/details/74453915" target="_blank" rel="noopener">这篇博客</a>中内部实现的部分。<br>​  在实际应用时，注意不要犯一些不该犯的错误，就比如在包外访问包访问权限的 public 构造器，这也是书中给的示例。也就是说访问一个字段或者方法之前，要先看看这个类是不是你能访问的。</p><h3 id="默认包访问权限">默认包访问权限</h3><p>  有时我们会想如果没有把一些类放在一个包，而是一起放在了一个普普通通的目录下，Java 还允许这写文件相互进行访问吗？答案是可以的。 这是因为 Java 把这样无家可归的文件看作是隶属于该目录的<strong>默认包</strong>中，并为它们提供了包访问权限。</p><h3 id="有没有必要-private">有没有必要 private</h3><p>  之所以这么说是因为默认的包访问权限已经提供了足够的隐藏措施。光是默认权限就足矣让客户端程序员不去乱碰他们不该碰的东西，并且让库程序员随意更改代码逻辑。那既然我们的目的已经都达成了，干嘛还需要 private 修饰符呢？<br>​  确实，也因此，最初的程序员都不怎么用关键字 private，因为程序没有它也可以照常工作。然而，使用 private 依然是非常重要的，尤其是在多线程环境中，这部分内容将在&quot;并发编程&quot;那一章中看到。<br>​  那你的意思就是说在学多线程之前，private 还是没什么用喽。其实还不是的，因为我们还可以利用 private 控制对象的创建，防止别人直接访问某个构造器。Just like this.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sundae</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Sundae <span class="title">makeASundae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sundae();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- Sundae x = new Sundae();</span></span><br><span class="line">    Sundae x = Sundae.makeASundae();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  除此之外，任何非主方法(意指主要方法，并不一定是 main 方法)，也就是辅助主方法的其它方法，都应声明为 private，这样就避免了其它类误用这个方法，也防止你去改变或删除它。并且最好把类中的属性也声明为 private。这都是一种规范也是一种习惯。</p><h2 id="接口和实现">接口和实现</h2><p>  一般来说程序具体的源代码就称作是<strong>实现</strong>，<strong>访问控制</strong>被称为<strong>实现隐藏</strong>，此外<strong>数据和方法包装到类</strong>后把<strong>具体实现隐藏</strong>称为是<strong>封装</strong>，最后你会得到一个同时带有特征和行为的数据类型。<br>​  一个编译单元只能有一个接口，而这个接口就有文件内的 public 类提供。当然文件中如果一个 public 类也没有也是完全没有问题的，这时文件名不受类名限制，但最好不要取一些令代码阅读者和维护者感到困惑的代码。<br>​  那我们还想禁止让外界访问那些不是 public 的类该怎么办。对于类的访问权限只有两种：包访问权限和 public。因此你不能从类的的修饰符下手，但可以将类的构造器声明为 private，这样只能通过类内部的 static 成员来创建对象了，因为 private 只允许自己访问自己。就像下面这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Soup1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title">makeSoup</span><span class="params">()</span> </span>&#123; <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Soup1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Soup2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1 = <span class="keyword">new</span> Soup2(); <span class="comment">// [2]</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ps1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one public class allowed per file:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Can't do this! Private constructor:</span></span><br><span class="line">    <span class="comment">//- Soup1 soup = new Soup1();</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Soup1 soup = Soup1.makeSoup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Soup2.access().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  上述例子给出了两个选择：在 Soup1 中，有一个 static 方法，它的作用是创建一个新的Soup1 对象并返回对象的引用。如果想要在返回引用之前在Soup1 上做一些额外操作，或是记录创建了多少个Soup1 对象（可以用来限制数量），这种做法是有用的。<br>​  Soup2 用到了所谓的设计模式。这种模式叫做单例模式，因为它只允许创建类的一个对象。Soup2 类的对象是作为Soup2 的static private 成员而创建的，所以有且只有一个，你只能通过public 修饰的access() 方法访问到这个对象。</p></blockquote><p>下面是书中在接口和实现部分对提升代码可读性的建议。</p><blockquote><p>为了清晰起见，你可以采用一种创建类的风格：<br>  public 成员放在类的开头，接着是 protected 成员，包访问权限成员，最后是 private 成员。这么做的好处是类的使用者可以从头读起，首先会看到对他们而言最重要的部分（public 成员，因为可以从文件外访问它们），直到遇到非 public 成员时停止阅读，下面就是内部实现了。</p></blockquote><h2 id="小结">小结</h2><blockquote><p>当了解到犯错是相对安全的时候，你可以更加放心地实验，更快地学会，更快地完成项目。</p></blockquote><p>  <strong>类的 public 接口是用户真正看到的，所以一定要认真设计和分析这个接口</strong>。访问权限控制关注的是类库创建者和外部使用者之间的关系，是一种交流方式。但你若自己一个人编写了所有的代码，或是在一个小组中工作，所有的东西都放在同一个包下。在这种独特的交流方式下，使用默认包访问权限或许就足够了，一味地严格地遵循访问权限规则不是明智的选择。</p><h1 id="复用">复用</h1><!--预习，复习，作业，数学，英语-->]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入坑Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学中的概念与术语</title>
      <link href="/2020/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD/"/>
      <url>/2020/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p><strong>计算机领域中高频、重要或者易混淆的概念及术语的解释。</strong><br>(长期更新)</p><a id="more"></a><h1 id="阅前须知">阅前须知</h1><p>​这篇博文会记录作者所学时遇到的一些**计算机领域中高频、重要或者易混淆的概念及术语的解释。**你是否遇到过这种情况：阅读书籍或论文时遇到了一个常见名词，觉得没什么大不了的之后继续往下读，发现越往下读越困难。回头发现这个名词原来在计算机领域中是个专有名词，与其在日常生活中的理解大相径庭。或者你已经被各式各样的英文单词及其大写缩写弄得晕头转向了呢？</p><p>正确的使用该篇博文的姿势：</p><ol><li>在浏览器内，使用快捷键 <code>ctrl + F</code> ，输入你想检索的概念或术语；</li><li>如果你 <code>ctrl + F</code> 没有效果，可以去安装一个页内检索插件，之后再进行上述步骤；</li><li>如果插件也没有找到，可以利用左边的目录来快速抵达你想要去的类别。</li></ol><ul><li><p>A 对 B 透明</p><ul><li>在计算机科学中，从某个角度看不到的特性就称这个特性是透明的。比如我们写代码时，变量的地址是由编译系统分配的，那么我们就称这个地址对我们是完全透明的，因为我们根本不知道变量的具体地址，这与现实生活中理解的透明正好相反。</li></ul></li><li><p>抽象</p><ul><li>​抽象一词的本意是指人在认识思维活动中对事物<strong>表象因素的舍弃</strong>和对<strong>本质因素的抽取</strong>。其具体过程大体是这样的：从解答问题出发，通过对各种经验事实的比较，分析，排除那些无关紧要的因素，提取研究对象的重要特征，加以认识从而为解答问题提供某些科学定律或一般原理。<br>​抽象化是用来减少程序的<strong>复杂度</strong>，以得到论域中较简单的概念，让人们更好地在编程时<strong>专注少数但重要的部分</strong>。抽象时要注意是否漏掉重要特征，防止抽象的成品，即算法出现问题。<br>​对于复杂系统问题人们借助<strong>分层次抽象</strong>的方法进行问题求解；在抽象的最高层，可以使用问题环境的语言，以<strong>概括的方式</strong>叙述问题的解。在抽象的较低层，则采用<strong>过程化的方式</strong>进行描述。<br>​计算机科学中遇到的所有问题都可通过增加若干层抽象来解决，由于计算机科学，本身就是一门抽象的科学，因此不论是硬件设计还是软件设计，都遵从这一规则。例如，汇编语言是机器语言的一层抽象；C语言是汇编语言的一层抽象；java中对象是基本数据类型的一层抽象；java虚拟机是操作系统的一层抽象；面向接口的编程是直接类耦合调用的抽象。高级语言的出现，使得程序的编写得以简化，极大提高了程序的编写效率。关于抽象更具体的内容，可移步至[维基词条](<a href="https://wiki.hk.wjbk.site/baike-%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">https://wiki.hk.wjbk.site/baike-%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)</a>以及<a href="https://wenku.baidu.com/view/4be50fdfa58da0116c1749ca.html" target="_blank" rel="noopener">百度文库</a>。</li></ul></li><li><p>OOP(ObjectOriented Programming)</p><ul><li>面向对象程序设计</li></ul></li><li><p>Class</p><ul><li>类</li></ul></li><li><p>Object（对象）</p><ul><li>包含一定的数据结构和状态的实体</li></ul></li><li><p>Operation（操作）</p><ul><li>作用于对象的行为，如访问或使用对象的成员</li></ul></li><li><p>Encapsulation（封装）</p><ul><li>定义对象和操作，仅提供抽象的接口</li></ul></li><li><p>Inheritance（继承）</p><ul><li>根据已有的类，新建数据类型，超类发生改变子类也会相应地发生变化</li></ul></li><li><p>Polymorphism（多态性）</p><ul><li>==判定数据类型集合中各类型的区别，使程序可以按照它们的共同特性来书写==</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念及术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初见数据结构与算法</title>
      <link href="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>初学者快速上手数据结构与算法</strong></p><a id="more"></a><p><strong>阅前须知</strong>：本文仅提供学习数据结构与算法的一个初步的知识框架，仅供参考，实际效果因人而异。该文章所参考的书籍绝大部分来自《算法图解》，少部分来自《算法导论》。本文所有的代码示例均用 Python 语言编写，全文也只有四处很短的代码块，代码落地程度不高，代码量不够的读者也可以阅读。</p><blockquote><p>  我承认，精准且严谨的定义固然是重要的，因为所有与之相关的理解都要建立在这个定义的基础上。但有时有些晦涩的定义直接上手可能会非常地棘手，因此可以先从定义的相关的应用或实例入手，通过<strong>合理恰当的打比方</strong>的方式，先对定义产生初步的了解，再通过练习不断地修正，力图接近真实的定义，最终可以达到所谓事半功倍的效果。<br>  因此，我想表达的是，文章可能会出现几处严谨性欠佳的描述，我会在那后面力争把它“圆”回来，并附上一个或者多个认可度较高的定义及出处。</p></blockquote><h1 id="何为算法">何为算法</h1><p>  《算法导论》对算法的定义为：非形式地说，算法就是任何良性定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样的算法就是把输入转换成输出的计算步骤的一个序列。<br>  讲真，上面这段定义看不看懂不重要，算法其实就是一组完成任务的指令，任何代码片段都可视为算法。如果还是没有感觉，可以姑且认为算法就是函数三要素中的<strong>对应法则 f</strong> 即可，我们只需知道算法的重要性以及应用就够了。<br>  算法可谓是现代信息技术的灵魂，它指挥着各种各样可处理的数据。一个<strong>优秀</strong>的算法要求在<strong>尽可能短的时间和空间</strong>内结束并返回<strong>正确的结果</strong>。于是，评判一个算法优劣的指标——<strong>时间复杂度</strong>和<strong>空间复杂度</strong>，应运而生。其中，时间复杂度常常用<strong>大 O 表示法</strong>进行合理地量化并表示。</p><h2 id="算法思想">算法思想</h2><p>  枚举，搜索，贪心，随机，递归，二分，分治，动态规划。这些都是一些最基础的算法思想，它们本身不仅是具体落地的算法，更是算法框架。这些框架之间相互组合，就又能延伸出非常多五彩斑斓的算法。这其中思想的奇妙性就在于，它并不是一个确实存在的东西，却又能任意转化成令人醍醐灌顶的产物，简洁但深刻。<br>  论暴力，目前恐怕谁都比不过电子计算机的运算能力。一台普通的 Laptop，每秒也能进行上亿次计算。上面说的所有的算法，本质都是在计算机变态一般的计算力的基础上，对数据的存储及其处理所做的一些列的优化过程。</p><h3 id="枚举">枚举</h3><p>  枚举也是要讲究方法的。就比如，明明这样的情况已经非法，但如果还是在一味地枚举，就徒劳地增加了计算机运算负担。通过有限次的枚举，最终返回正确结果的过程叫做<strong>搜索</strong>。而中途遇到非法情况，从而退回重置到原来的某一个步骤的过程叫做<strong>回溯</strong>。枚举时所用的数据一般是特意选择后得到的，这样的选择策略一共有两种：<strong>贪心</strong> 以及 <strong>随机</strong>。<u>贪心既是贪取利益最大的选择，随机则是通过随机的方式进行选择</u>。</p><h3 id="分治">分治</h3><p>  分治，分而治之的简称，是将大问题分为子问题 <strong>以大化小</strong>的算法思路，也是使用频率非常高的算法。比如当我们翻阅字典时，除了依靠目录查询，人们更喜欢将字典从中间摊开放在桌面上，进行所谓的<strong>二分查找</strong>。这里的二分查找就用到了分治的思想。又比如之后要介绍的<strong>动态规划</strong>算法，即将问题拆分为子问题，在计算过程中利用之前计算过的结果，避免重复计算。<br>  分治大家庭中，<strong>递归</strong>的地位也比较高。这是个非常有意思的算法思想。形式上就是一系列相似的问题，通过我调用我自己，像套娃一样层层拆分，直到达到基线条件。调用栈的层数越多，问题就越简单的，且最上层的问题是可以直接解出来的，但调用栈层数过多时，递归的效率就会非常低下。某种程度上，递归就是以大博小，动态规划则是以小博大。递归典型的例子就是汉诺塔问题，当然更具体的内容之后会安排上。</p><h2 id="大-O-表示法">大 O 表示法</h2><p>  设待处理的数据规模为 n，我们<strong>不关心</strong>计算机每次处理一份数据时所花的时间到底有多长，<strong>只关心</strong>计算机处理这 n 个数据时所耗费的总操作数。一般用大写的 “O” 表示。</p><p>下面是常见算法的时间复杂度，其中 O(log n) 中的 log n 习惯认为是以 2 为底的对数。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" alt></p><p>  可能一个算法的实际时间复杂度为 O( 3*n! + 0.5*n log n + 7 )。那么<strong>规定该算法的时间复杂度就是当 n 趋于无穷大时，在上面常见时间复杂度中与其同阶无穷大的时间复杂度</strong>。这样化简后的时间复杂度表示为 O(n!) 即可。值得一提的是，O(1) 表示<strong>常量时间</strong>，意为无论数据规模有多大，这个算法只需要一步就能搞定。</p><p>  前面提到的《算法导论》中，有句话特别在理：<strong>Having a solid base of algorithm knowledge and technique is one characteristic that separates the truly skilled programmers from the novices.</strong><br>意为，是否具有扎实的算法知识和技术基础，是区分真正熟练的程序员与新手的一项重要特征。</p><h1 id="数组与链表">数组与链表</h1><p>  你需要将<strong>内存空间</strong>想象成宾馆储物抽屉柜，每个抽屉只能储存一个物品。如下图所示。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%85%E5%AD%98%E6%8A%BD%E5%B1%89.jpg" alt></p><p>  你可以选两种储存方式，一种是使用<strong>连续地</strong>进行储存，这种存储结构的管理方式好处和坏处都很明显，<strong>好处</strong>是你只需要记住第一个物品的位置，就可以瞬间知道第几个物品的位置在哪里。<strong>坏处</strong>是当你抽屉组的最前端和最后段都有物品时，如若需要增加物品，你只能把所有元素全部搬到更大的连续的抽屉组中，非常费力，当然你也可以提前申请足够大的空间，但如若最后用不上那么多，即是对空间的极度浪费。<br>  另外一种是<strong>离散地</strong>进行储存，并且上一个抽屉储存着下一个抽屉的位置，即 当查看第 n 个抽屉的内容时，就顺势直到第 n+1 个抽屉的位置在哪里了。这种存储结构的<strong>优势</strong>是你没有前一种存储方式的顾虑，可以随意在任意位置添加元素，删除第 n 个元素时，只需将第 n-1 个抽屉记录第 n+1 个位置即可。但如若想知道第 n 个抽屉位置，就需要 n-1 个抽屉的位置，以此类推，需要全部遍历，效率比较低下，<strong>不支持随机访问</strong>。<br>  第一种就像是数据结构中的<strong>数组</strong>，第二种就像是数据结构中的<strong>链表</strong>。如若经常需要从头遍历所有元素，用链表会更好一些，但若经常需要随机访问元素，则一般需要用数组。或者更一般地来说，<strong>如果打算创建下来之后不会再修改其长度，就用数组，否则用链表</strong>。<br>  数组和链表还被用来实现其他数据结构，比如 Facebook 实际使用的是什么呢？很可能是十多个数据库，他们居于众多不同数据结构：散列表、B数等。数组和链表使这些更复杂的数据结构的基石。</p><h1 id="递归">递归</h1><p>  每个递归算法都由两个不可或缺的部分组成：<strong>基线条件（base case）和递归条件（recursivecase）</strong>。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>  只要是数据结构，都有属于自己的操作。例如数组和链表就有读取、插入、删除、修改等操作。而对于<strong>栈</strong>来说，它的操作只有<strong>压入(push)<strong>和</strong>弹出(pop)</strong>。当一个栈用于存储多个函数的变量时，被称为<strong>调用栈</strong>。因为每当你调用函数时，计算机都将函数调用所涉及的变量的值存储到内存中。当一个函数调用返回时，就从栈的顶部弹出。<br>  使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择。一种是将递归化为循环解决，另一种是<strong>尾递归</strong>，当然这就是另一个故事了。</p><h1 id="分治-v2">分治</h1><p>  有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的 算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。<strong>分而治之</strong>（divide and conquer，D&amp;C）是你学习的第一种通用的问题解决方法。快速排序就是使用分而治之策略的一种优雅的排序算法。</p><p>D&amp;C 思路是递归的，使用 D&amp;C 解决问题的过程包括两个步骤：</p><ol><li>找出简单的基线条件。</li><li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li></ol><p>  编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，有必要检查一下基线条件是不是这样的。</p><h2 id="函数式编程">函数式编程</h2><p>  诸如 <strong>Haskell</strong> 等函数式编程语言没有循环，因此你只能使用递归来编写类循环。例如，函数 sum 可以这样编写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum[] = <span class="number">0</span></span><br><span class="line">sum(x:xs) = x + (sum xs)</span><br><span class="line"><span class="comment"># 用函数式程序设计语言 Haskell 所编写的 sum 函数。</span></span><br><span class="line"></span><br><span class="line">sum arr = <span class="keyword">if</span>  arr == []</span><br><span class="line">            then <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span> (head arr) + (sum (tail arr))</span><br><span class="line"><span class="comment"># 用循环编写 sum 函数。</span></span><br></pre></td></tr></table></figure><p>  <strong>归纳证明</strong>是一种证明算法行之有效的证明方式。它分为基线条件和归纳条件，在数学领域中被称为第一类数学归纳法。归纳证明常常与 D&amp;C 协同发挥作用。</p><h2 id="快速排序">快速排序</h2><p>  C语言标准库中的 <strong>qsort</strong> 函数实现的就是快速排序，是一种比选择排序快得多的排序算法，快排的平均大 O 运行时间为 O(n*log n )。其基本步骤为：</p><ol><li><p>数组的 pivot[^基准值]的选取。</p></li><li><p>分别创建两个数组，其中包含除 pivot 外小于等于 pivot 的，以及大于 pivot 的。</p></li><li><p>分别再对这两个数组进行快排。</p></li></ol><p>  快速排序的实际运行时间很大程度上都由 pivot 决定，如果 pivot 一直选取数组第一个元素时，它的栈的高度就为 n，每层的操作数也为 n，最终的运行时间为 O(n<sup>2</sup>)。而如果每次都选取中间的元素时，栈的高度就是 log n，每层的操作数还是 n。</p><h1 id="散列表">散列表</h1><p>  <strong>散列表</strong>，又称<strong>哈希表(hash table)</strong>，由散列函数和数组构成。任意一个可处理的输入数据，经过散列函数后，可将输入数据映射到数组中某个位置的内存地址中，内存地址又可以另外指向其它具体的数据，这个数据则被称作是<strong>散列值</strong>，简称<strong>值</strong>。充当<strong>值</strong>的数据类型可以是<strong>任意类型</strong>。而前面输入数据则被称作是<strong>键</strong>，充当<strong>键</strong>的数据类型只能是<strong>不可变类型</strong>。<strong>理想的散列函数</strong>能够保证所有不同的键映射的内存地址互不相同。但正因为是理想，所以现实情况中很难办到。当不同键映射到同一处内存地址时，就会产生<strong>冲突</strong>。要想化解冲突，只需将数组这个位置的内存地址指向一个<strong>链表</strong>即可，之后在这个链表中存储各自想要储存的值即可。如下图所示。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%B2%E7%AA%81.jpg" alt></p><p>  但如果某个链表的所涉及的元素过多，查找散列表的速度会比较慢，以至于在最糟情况时，散列表的各种操作的运行时间都是 O(n)。想要尽可能地避免冲突，需要有<strong>较低的装填因子</strong>以及<strong>良好的散列函数</strong>，当然这就是另一个故事了。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">散列表(平均情况)</th><th style="text-align:center">散列表(最糟情况)</th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">读取</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr></tbody></table><h2 id="散列表的应用">散列表的应用</h2><ul><li>将散列表用于查找<ul><li>储存电话号码和联系人似乎用散列表是比较好的，这是个简单例子。不妨稍微谈一下高级话题，比如 <strong>DNS 解析(DNS resolution)</strong>。访问像 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 这样的网站时，计算机要先将域名转换为 IP 地址,即 74.125.239.133，转换的过程其实就是将网址映射到 IP 地址上去。因此用散列表的特性来做是极好的。</li></ul></li><li>将散列表用作缓存<ul><li>缓存是一种常用的加速方式，几乎任何的大型网站都会使用缓存，而缓存的数据则会储存在散列表中。当你访问 Facebook 的网页时，你会先接入他们的服务器，如果某个网页所有用户看到的都应该是一样的，那就会将事先保存好的网页展示给你，就像是所有人的登陆界面一样。否则服务器就对网页做些处理，将生成的网页展示给你，比如你的个人空间。这就是缓存，它能使用户更快地看到网页，也因此 Facebook 需要做的计算量更少。</li></ul></li><li>防止重复</li></ul><h1 id="广度优先搜索">广度优先搜索</h1><blockquote><p>根据《算法图解》的作者所知道的算法中，图算法应该是最有用的，而广度优先搜索就是图算法的一种，它能够找出两样东西之间的最短距离。</p></blockquote><h2 id="最短路径问题">最短路径问题</h2><p>  像从旧金山双子峰到金门大桥的最少换成次数，或者去你朋友家的最短路径，再或者是国际象棋中把对方将杀死的最少步数。都被称为是最短路径问题。</p><p>要解决最短路径问题通常需要两个步骤：</p><ol><li>使用图来建立问题模型；</li><li>使用广度优先搜索解决问题。</li></ol><h2 id="何为图？">何为图？</h2><p>  <strong>图用于模拟不同的东西是如何相连的</strong>，它由<strong>节点</strong>和<strong>边</strong>组成，一个节点所<strong>直接指出去</strong>的所有节点统一称作是<strong>邻居</strong>。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE2.jpg" alt></p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE1.jpg" alt></p><h2 id="何为广度优先搜索">何为广度优先搜索</h2><p>广度优先搜索是一种用于<strong>图</strong>的<strong>查找算法</strong>，它可以解决两类问题：</p><ol><li><p>从节点 A 出发，有通往节点 B 的路径吗？</p></li><li><p>如果有，那么从节点 A 出发，通往节点 B 的哪条路径最短？</p></li></ol><p>  以节点 A 为中心，节点 A 的邻居被称为是节点 A 的<strong>一度关系</strong>，邻居的邻居被称为是<strong>二度关系，以此类推</strong>。在广度优先搜索看来，<strong>一度关系胜过二度关系，二度胜过三度</strong>，因此它会先在一度关系中查找节点 B，一度没有就找二度，二度没有就去三度，<strong>直到找到为止或者所有的节点都遍历过一遍为止</strong>。</p><h2 id="队列">队列</h2><p>  队列的工作原理与现实生活中的队列完全相同，是一种数据结构。它只支持两种操作，即<strong>入队</strong>和<strong>出队</strong>。Python 中可以从 cllections 库中引入 deque 函数来创建一个双端队列。<br>  为了实现广度优先搜索算法，我们需要先实现图，再去通过队列的先进先出的特性来实现算法。</p><h2 id="实现图">实现图</h2><p>  没有邻居的节点被称为是<strong>有向图</strong>，互为邻居的节点被称为是<strong>无向图</strong>。像这样一个节点对应多个节点的结构像极了映射，因此我们可以用<strong>散列表</strong>来储存图，将每个节点设为键，每个节点的邻居设为值。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE3.jpg" alt></p><h2 id="实现算法">实现算法</h2><p>先用队列按照几度关系的顺序依次将节点入队。具体步骤为：</p><ol><li>创建一个搜索队列；</li><li>将中心节点的邻居添加至队列中；</li><li>只要搜索队列不是空的，建立循环；<ol><li>将一个节点 popleft() 赋值给变量 P</li><li>检查 P 有没有被检查过<ol><li>检查 P 是不是<strong>目标节点</strong><ol><li>如果是则返回 True</li><li>如果不是则将 P 的邻居添加到队列中</li></ol></li></ol></li></ol></li><li>返回 False。</li></ol><p>  在最糟糕的情况下，你需要遍历整个图，也就是说每条<strong>边</strong>都要走一次，并且你需要对每个节点进行依次检查，于是时间复杂度为 <strong>O(V + E)</strong>，其中 V(vertical)为节点数，E(eadg) 为边数。</p><h1 id="狄克斯特拉算法">狄克斯特拉算法</h1><p>  如果说广度优先搜索是解决<strong>最短路径</strong>问题，那么狄克斯特拉算法就是解决<strong>最快路径</strong>问题。应用狄克斯特拉算法时，图中每条边都有与之相关联的<strong>数字</strong>，这叫做权重。并且，带权重的图被称为是<strong>加权图</strong>，不带权重的图被称为时<strong>非加权图</strong>。值得一提的是狄克斯特拉算法只适用于<strong>有向无环图</strong>且<strong>无负权边</strong>的情况。</p><p>狄克斯特拉算法包含以下几个步骤：</p><ol><li>设中心节点为 A，列出如下表格；</li></ol><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">父节点</th><th style="text-align:center">耗时</th></tr></thead><tbody><tr><td style="text-align:center">A 的邻居 B</td><td style="text-align:center">A</td><td style="text-align:center">α</td></tr><tr><td style="text-align:center">A 的邻居 C</td><td style="text-align:center">A</td><td style="text-align:center">β</td></tr><tr><td style="text-align:center">非 A 的邻居 D</td><td style="text-align:center">其它</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">目标节点</td><td style="text-align:center">其它</td><td style="text-align:center">∞</td></tr></tbody></table><ol start="2"><li>循环开始；<ol><li>找出所有节点中**“耗时”最少**的节点，在这里不妨设 α &lt; β，因此我们很轻松地找出了节点 B。</li><li>计算 A 到 B 每个邻居的“耗时”，若 结果 小于 原有结果，则<strong>更新相应节点的“耗时”与“父节点”的值。</strong></li><li>由于 B 的邻居都已更新完毕，因此 节点 B <strong>不再参与</strong>下一轮的循环。<strong>直到所有节点的邻居更新完毕。</strong></li></ol></li><li>根据目标节点的父节点，向前依次<strong>追踪节点</strong>，直到某个节点的父节点为 中心节点 A，得出完整最短路线。</li></ol><p>Q：为什么算法实现的充分条件是<strong>有向无环图</strong>？</p><p>A：若节点与节点之间相互成“环”，那么每循环“环”一次总耗时就要无意义地增加，这样的路径不可能是<strong>最快路径</strong>。</p><p>Q：为什么算法实现的充分条件是<strong>不存在负权边</strong>？</p><p>A：若含有负权边，那么在后续的循环中，有可能会更新之前已经淘汰掉的节点的“耗时”以及“父节点”的值，如上述的 节点 B，这时理应要再对 节点 B 进行一次检查，可是由于 节点 B 已经淘汰掉了，因此无法更新 B 的邻居们。所以可能会使<strong>真实结果</strong>和<strong>实际演算结果</strong>产生不小的出入（其实就是贪心的锅，导致只能求得近似解），狄克斯特拉算法看起来就像是出了 bug 一样。因此，应对这种情况，我们必须换一个算法来实现——<strong>贝尔曼-福德 算法</strong>，当然这就是另一个故事了。</p><h2 id="关于实现">关于实现</h2><p>  以表格作为算法的出发点，需要用到三个散列表来装填三种数据，即 graph , parents , costs，而其中 graph 还需要存储各个边的权重，因此需要再套一层散列表，即 第一层 = 键 : 值 = <strong>节点 : 第二层散列表</strong>，第二层 = 键 : 值 = <strong>邻居 : 边的权重</strong>。</p><h1 id="贪心算法">贪心算法</h1><p>​贪心算法，又称贪婪算法，即 每步都选择的<strong>局部最优解</strong>，最后得到<strong>近似</strong>全局最优解或<strong>全局最优解</strong>，采取的是一种步步为“赢”的策略手段。<br>  在一些问题中，有时你不得不需要计算出所有合法情况下的解。这种问题就被称作为 <strong>NP完全问题</strong>。在每次计算出的解集中，从中选出最符合题意条件的解，从而求得精确最优解。而往往这种暴力算法所带来的运行速度都是非常糟糕的，这时需要采用贪心算法。虽然多数情况下只能求得近似解，但时间复杂度要比纯暴力计算好看得多。</p><h2 id="NP完全问题模型—集合覆盖问题">NP完全问题模型—集合覆盖问题</h2><p>  假设你办了个广播节目，要让全美 50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。广播台的名单 demo 如下。</p><table><thead><tr><th style="text-align:center">广播台</th><th style="text-align:center">覆盖的州</th></tr></thead><tbody><tr><td style="text-align:center">KONWE</td><td style="text-align:center">ID,NV,UT</td></tr><tr><td style="text-align:center">KTWO</td><td style="text-align:center">WA,ID,MT</td></tr><tr><td style="text-align:center">KTHREE</td><td style="text-align:center">OR,NV,CA</td></tr><tr><td style="text-align:center">KFOUR</td><td style="text-align:center">NV,UT</td></tr><tr><td style="text-align:center">KFIVE</td><td style="text-align:center">CA,AZ</td></tr></tbody></table><p>  每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。而我们呢现在的问题是如何找出覆盖全美 50个州的最小广播台集合，这听起来很容易，但其实运算量极大，具体方法余下。</p><ol><li>列出每个可能的广播台集合，这被称为 幂集（power set）。因此，可能的子集有 2<sup>n</sup>个（包括空集）。</li><li>在这些 2<sup>n</sup>个子集中，选中覆盖全美 50个州的最小集合。</li></ol><p>  当然，n 在 0~10 的区间范围内还好说，但当 n 超过了这个范围，实际操作数将急剧增加，更为痛苦的是，目前<strong>没有任何算法</strong>可以足够快地解决这个问题。这时就需要**近似算法（approximation algorithm）**解决类似的问题，具体方法如下。</p><ol><li>选出这样一个广播台，即 它覆盖了最多的未覆盖州。即便这个广播台也同时覆盖了一些已覆盖的州，也没有关系。</li><li>重复第一步，直到覆盖了所有的州。</li></ol><p>具体的 Python 代码实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">states_needed = set([<span class="string">"mt"</span>, <span class="string">"wa"</span>, <span class="string">"or"</span>, <span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>, <span class="string">"ca"</span>,<span class="string">"az"</span>])  <span class="comment"># 传入一个数组，并转换为集合。</span></span><br><span class="line">arr = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">stations = &#123;&#125;  <span class="comment"># 需要有可供选择的广播台清单，使用散列表来表示它。</span></span><br><span class="line">stations[<span class="string">"kone"</span>] = set([<span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"ktwo"</span>] = set([<span class="string">"wa"</span>, <span class="string">"id"</span>, <span class="string">"mt"</span>])</span><br><span class="line">stations[<span class="string">"kthree"</span>] = set([<span class="string">"or"</span>, <span class="string">"nv"</span>, <span class="string">"ca"</span>])</span><br><span class="line">stations[<span class="string">"kfour"</span>] = set([<span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"kfive"</span>] = set([<span class="string">"ca"</span>, <span class="string">"az"</span>])</span><br><span class="line">final_stations = set()  <span class="comment"># 需要一个集合来储存最终选择的广播台。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> states_needed:  <span class="comment"># 不断地循环，直到states_needed为空。</span></span><br><span class="line">    best_station = <span class="literal">None</span>     <span class="comment"># 准备遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台存储在 best_station 中。</span></span><br><span class="line">    states_covered = set()</span><br><span class="line">    <span class="keyword">for</span> station, states <span class="keyword">in</span> stations.items():  <span class="comment"># for循环迭代每个广播台，并确定它是否是最佳的广播台。</span></span><br><span class="line">        covered = states_needed &amp; states  <span class="comment"># covered 包含当前广播台覆盖的一系列还未覆盖的州</span></span><br><span class="line">        <span class="keyword">if</span> len(covered) &gt; len(states_covered):  <span class="comment"># 检查该广播台覆盖的州是否比 best_station 多。</span></span><br><span class="line">            best_station = station</span><br><span class="line">            states_covered = covered  <span class="comment"># states_covered 包含该广播台覆盖的所有未覆盖的州。</span></span><br><span class="line">            states_needed -= states_covered  <span class="comment"># 更新 states_needed。</span></span><br><span class="line">            final_stations.add(best_station)</span><br><span class="line"></span><br><span class="line">print(final_stations)  <span class="comment"># 输出结果为 set(['ktwo', 'kthree', 'kone', 'kfive'])</span></span><br></pre></td></tr></table></figure><h2 id="NP完全问题模型—旅行商问题">NP完全问题模型—旅行商问题</h2><p>  有一位旅行商，他需要前往 n个城市，同时保证旅程最短。因此他需要考虑各种各样可能的顺序情况，而对于每种顺序，他都要计算总旅程，再挑选出旅程最短的路线，那么很明显，他需要考虑 n! 个顺序情况。<br>  针对这种问题，当 n 比较大时，可以采取贪婪算法，具体步骤为。</p><ol><li>选定一个起点城市。</li><li>去往离起点城市最近的城市，并将起点城市更新为该城市。</li><li>重复上述步骤。</li></ol><h2 id="如何识别NP完全问题">如何识别NP完全问题</h2><p>  旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。<br>  通常来说，用 贪婪算法 解决一个 NP完全问题并不难，而真正难的部分则是意识到这是个 NP完全问题。下面列出几个判断 NP完全问题的经验性规律。</p><p>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</p><ul><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ul><h1 id="动态规划">动态规划</h1><blockquote><p>  动态规划相较于其它算法来说，是属于比较重要，但同时也比较麻烦的一种算法。因此这里先了解一个例子再根据这个例子具体说明可能会好理解一点。</p></blockquote><h2 id="背包问题">背包问题</h2><h3 id="描述">描述</h3><p>  假设你现在是一个不折不扣的小偷，晚上进商城准备偷东西，你的背包很神奇，它装东西本领只和这个东西的重量有关，不妨限定你的背包最多只能装 4kg的东西。下面是你想偷的东西的清单，每件商品只有一个。</p><table><thead><tr><th style="text-align:center">商品</th><th style="text-align:center">音响(S)</th><th style="text-align:center">笔记本电脑(L)</th><th style="text-align:center">吉他(G)</th><th style="text-align:center">IPhone(I)</th></tr></thead><tbody><tr><td style="text-align:center">价格</td><td style="text-align:center">￥3000</td><td style="text-align:center">￥2000</td><td style="text-align:center">￥1500</td><td style="text-align:center">￥2000</td></tr><tr><td style="text-align:center">重量</td><td style="text-align:center">4kg</td><td style="text-align:center">3kg</td><td style="text-align:center">1kg</td><td style="text-align:center">1kg</td></tr></tbody></table><p>  你的目标很明确，在有限的容量里装入尽可能多的有价值的物品。因为你明白这其中要满足某种配比才有可能是问题的最优解（比如，拿走一个 笔记本电脑 和一个 IPhone 才可能是最赚的），但你不确定。因此，你掏出纸和笔打算写一个动态规划网格。我承认这可能很突然，但先照着做一下。</p><table><thead><tr><th style="text-align:center">商品/容量</th><th style="text-align:center">1kg</th><th style="text-align:center">2kg</th><th style="text-align:center">3kg</th><th style="text-align:center">4kg</th></tr></thead><tbody><tr><td style="text-align:center">吉他</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">音响</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">笔记本电脑</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">IPhone</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>  其中，网格的各行为商品，各列为不同容量（1~4kg）的背包。首先要声明的是，待会儿要填满这里所有的单元格，因为它们将帮助你计算背包的最大价值。<strong>你要做的事情是</strong>：逐行填写，填完一行再填下一行。填 a 行 b 列时，你假定现在只能偷 <strong>小于等于 a 行</strong> 的商品，且你的背包大小只有 <strong>b kg</strong>。举个例子，当你填 <strong>第二行 第三列</strong> 的单元格时，你只能偷 <strong>吉他</strong> 以及 <strong>音响</strong>，并且你的背包容量只有 <strong>3kg</strong>，这时将所能带走的最大价值填入所对应的单元格中。</p><h3 id="揭晓">揭晓</h3><p>  看完上面有点懵是正常的，觉得意义不明也有可能，因此需要适当“放”出来一点东西出来缓和以下。<br>  动态规划讲究将原问题划分为 n 个子问题，所以我们才将背包容量这个<strong>限制条件</strong>划分成 4 大块。通过解决第 1 个子问题，<strong>保存</strong>结果，接着解决第 2 个子问题时可以<strong>调用</strong>之前的结果，类似于尾递归。因此填表的时候沿着一列往下走时，最大价值不可能降低。因为每次迭代时，你都存储了当前的最大价值，最大价值不可能比之前还要低。<br>  值得一提的是，这 n 个子问题之间必须是相互独立且<strong>离散</strong>的。拿背包问题举例，如果拿了笔记本电脑之后再拿 IPhone 时电脑会爆炸，简言之就是电脑的价值会受手机的影响，这样的情况是用不了动态规划的。<br>  设行数为 i，列数为 j，cell 表示表格， α 为当前物品的价值，β 为当前物品的所占空间，则：<strong>cell[i][j] = max{cell[i-1][j] , α + cell[i-1][j-β]}</strong>， 即<br><strong>每个单元格的价值 = 上一个单元格的价值 与 当前商品的价值 + 剩余空间的价值 的两者的较大值</strong>。<br>  按照上述公式所填写的完整的表格如下，其中最大价值为￥4000，也就是说当你的容量只有 4kg 的背包，装一个 IPhone 和一个笔记本电脑时，收益才能达到最大化。</p><table><thead><tr><th style="text-align:center">商品/容量</th><th style="text-align:center">1kg</th><th style="text-align:center">2kg</th><th style="text-align:center">3kg</th><th style="text-align:center">4kg</th></tr></thead><tbody><tr><td style="text-align:center">吉他(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td></tr><tr><td style="text-align:center">音响(S)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥3000</td></tr><tr><td style="text-align:center">笔记本电脑(L)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥2000(L)</td><td style="text-align:center">￥3500(LG)</td></tr><tr><td style="text-align:center">IPhone(I)</td><td style="text-align:center">￥3500(I)</td><td style="text-align:center">￥3500(IG)</td><td style="text-align:center">￥3500(IG)</td><td style="text-align:center">￥4000(IL)</td></tr></tbody></table><p>  在背包问题中，任意调换某两行都不会影响最终结果，甚至逐列填写单元格也没关系，但在其它动态规划模型中就不一定成立了。你也可以在最后一行添加一个任意一个商品而不影响上面的计算结果，当然前提是这件商品的重量是个整数，如果不是整数则要重新划分价格区间。</p><h2 id="动态规划问题">动态规划问题</h2><ol><li>需要在给定<strong>约束条件</strong>下<strong>优化某种指标</strong>时。例如在背包问题中，你必须在背包容量给定的情况下，拿到价值最高的商品。</li><li>问题可分解为<strong>离散</strong>的子问题时。</li></ol><h2 id="动态规划的认知">动态规划的认知</h2><ol><li><strong>每种动态规划解决方案都涉及网络</strong>。</li><li><strong>单元格中的值</strong>通常就是你要<strong>优化的值</strong>。在背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你该考虑如何将问题分成子问题，这有助于你找出网格坐标轴。</li><li>没有放之四海而皆准的计算动态规划解决方案的公式。</li></ol><h2 id="动态规划问题建模">动态规划问题建模</h2><p>遇到动态规划问题时首先要问自己这么几个问题：</p><ol><li>单元格中的值是什么？或者说 在动态规划中，你要将哪个<strong>指标最大化</strong>？</li><li>如何将这个问题划分为子问题？</li><li>网格的坐标轴是什么？</li><li>应该使用什么样的公式来填充每个单元格？</li></ol><h2 id="所谓费曼算法">所谓费曼算法</h2><p>  动态规划实际上比较棘手的部分就是对动态规划问题的建模这一块，但有时你就是不确定具体到底该怎么做。这时，计算机科学家会开玩笑说：不妨就使用<strong>费曼算法（Feynman algorithm）</strong>。这个算法是以著名物理学家 理查德·费曼 命名的，算法具体步骤如下。</p><ol><li>将问题写下来。</li><li>好好思考。</li><li>将答案写下来。</li></ol><p>  由此我们知道，有些算法并非精确的解决步骤，而是会帮助你理清思路的框架，本质还是一种工序上的优化问题。</p><p>  接下来我们再来讨论三个动态规划问题，其中第一个和背包问题类似，其余两种则需要重新建模。</p><h2 id="旅游行程最优化">旅游行程最优化</h2><p>  加入你要去伦敦度假，假期两天，但你想去游览的地方有很多。由于你没法前往每个地方游览，因此如何在有限的时间内，游览地方的评分总和最高是你的目标。具体行程如下。</p><table><thead><tr><th style="text-align:center">名胜</th><th style="text-align:center">威斯敏斯特教堂(W)</th><th style="text-align:center">环球剧场(G)</th><th style="text-align:center">英国国家美术馆(N)</th><th style="text-align:center">大英博物馆(B)</th><th style="text-align:center">圣保罗大教堂(S)</th></tr></thead><tbody><tr><td style="text-align:center">时间</td><td style="text-align:center">0.5天</td><td style="text-align:center">0.5天</td><td style="text-align:center">1天</td><td style="text-align:center">2天</td><td style="text-align:center">0.5天</td></tr><tr><td style="text-align:center">评分</td><td style="text-align:center">7</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">8</td></tr></tbody></table><p>根据上面的清单以及背包问题的公式，我们可以非常轻松地填满如下表格。</p><table><thead><tr><th style="text-align:center">名胜/时间</th><th style="text-align:center">1/2</th><th style="text-align:center">1</th><th style="text-align:center">3/2</th><th style="text-align:center">2</th></tr></thead><tbody><tr><td style="text-align:center">威斯敏斯特教堂(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td></tr><tr><td style="text-align:center">环球剧场(G)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">13(WG)</td></tr><tr><td style="text-align:center">英国国家美术馆(N)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">16(WN)</td><td style="text-align:center">22(WGN)</td></tr><tr><td style="text-align:center">大英博物馆(B)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">16(WN)</td><td style="text-align:center">22(WGN)</td></tr><tr><td style="text-align:center">圣保罗大教堂(S)</td><td style="text-align:center">8(S)</td><td style="text-align:center">15(WS)</td><td style="text-align:center">21(WGS)</td><td style="text-align:center">24(WNS)</td></tr></tbody></table><h2 id="最长公共子串">最长公共子串</h2><blockquote><p>  有必要提前声明的是，<strong>最长公共子串</strong>讲究的是字符之间的连续性的，即 <strong>绝对顺序</strong>。相反，<strong>最长公共子序列</strong>讲究的是字符之间的<strong>相对顺序</strong>。举个例子，fosh 和 fish 的最长公共子串的长度为 2，最长公共子序列的长度为 3。fosh 和 fort 的最长公共子串的长度也是 2，但最长公共子序列的长度只有 2。</p></blockquote><p>  FISH 和 HISH 的最长公共子串的长度为多少？相信我们都可以一眼看出来，但对于计算机来说是要设计专门的算法来处理这样的问题的。<br>  首先判断这本质上应该是个动态规划问题，毫无疑问，这些个单词都可以分为单个离散的字符。并且，对于 FISH 来说 HISH 本身就是约束条件，反过来也一样。所要优化的指标当然也就是两者的 公共子串的长度。</p><p>根据以上分析判断这是个动态规划问题之后直接上网格表。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">H</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">I</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">S</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">H</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>  针对单元格中索要填入的的值，思考公式是什么。<strong>再次强调一下，公式只是表象，其内部还是子问题的保存和调用的一个尾递归。</strong></p><ol><li>如果两个字母不相同时，值 =  0。</li><li>如果两个字母相同时，值 = 左上角单元格的值 + 1。</li></ol><p>实现这个公式的伪代码类似于下面这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[j] == word_b[j]:<span class="comment"># 两个字母相同</span></span><br><span class="line">    cell[i][j] = cell[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    cell[i][j] = <span class="number">0</span><span class="comment"># 两个字母不同</span></span><br></pre></td></tr></table></figure><p>根据公式不难填满得到如下表格。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">H</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr></tbody></table><p>同理，HISH 和 VISTA 的最长公共子串如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">V</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">T</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>需要注意的是，最终的答案并不总在最后一个单元格中。</p><h3 id="最长公共子序列">最长公共子序列</h3><p>同样，利用上面的分析方法，也可以得到动态规划最长公共子序列的公式。</p><ol><li>如果两个字母不同，就选择上方和左边的单元格的值较大的哪个。</li><li>如果两个字母相同，就将当前单元格的值设置为左上方的单元格的值加 1。</li></ol><p>公式伪代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[i] == word_b[j]:<span class="comment"># 两个字母相同</span></span><br><span class="line">    cell[i][j] = cell[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:<span class="comment"># 两个字母不同</span></span><br><span class="line">    cell[i][j] = max(cell[i<span class="number">-1</span>][j],cell[i][j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>求 FOSH 和 FORT 的最长公共子序列的长度的网格如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">F</th><th style="text-align:center">O</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">T</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr></tbody></table><p>求 FOSH 和 FISH 的最长公共子序列的长度的网格如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">F</th><th style="text-align:center">O</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><h2 id="动态规划的实际应用">动态规划的实际应用</h2><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。</li><li>你使用过诸如 git diff 等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如 Microsoft Word 等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h1 id="K最近邻算法">K最近邻算法</h1><blockquote><p>​有些人说 网易云音乐 和 哔哩哔哩 有着一些 朋友交易。~~（举个例子，自己刚在哔哩哔哩看了触手猴翻奏了萃香的曲子的视频，不一会儿打开网易云音乐，首页上就推荐了 东方萃梦想/碎月/萃梦想 的同人曲歌单。）~~这其中的机制就和 <strong>K最近邻算法</strong>有关。</p></blockquote><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8D%E6%98%8E%E9%A3%9F%E7%89%A9.png" alt></p><p>  如上图，现在桌子上有一个水果，现在它只可能是橙子或者柚子中的一种，你不能直接问卖水果的人。手头上已知的条件是：**柚子通常比橙子更大、更红。**现在的问题是它最有可能是橙子还是柚子？</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E6%A0%87.png" alt></p><p>  不妨在脑内想象一个这么样的图表，其中 O 为橙子，G 为柚子，横坐标为大小，纵坐标为颜色的深浅。注意到，<strong>坐标轴是连续的，而水果则抽象成了一些离散的点，或者说向量。</strong><br>  那么如何大致判断这个神秘的水锅到底是什么呢？其实非常简单，不妨找一下离 神秘水果所表示的点 最近的三个水果，然后比较以下那种水果的种类更多即可。若假定 3个水果中，有两个都是橙子，那么这个神秘水果很有可能就是橙子。</p><h2 id="KNN算法">KNN算法</h2><p>  在判断那个水果的种类的过程中，其实已经使用了 K最近邻（k-nearest neighbours, KNN）算法。利用自然语言描述刚刚的 KNN算法过程如下。</p><ol><li>需要对一个水果进行分类。</li><li>查看它 K个最近的邻居。</li><li>在这些邻居中，橙子多余柚子，因此它很可能是橙子。</li></ol><p>  <strong>要对东西进行分类时，可以首先考虑采用 KNN算法。<strong>你可以使用 KNN 来做两项基本工作——<strong>分类</strong>和</strong>回归（regression）</strong>。</p><ul><li>分类就是编组；</li><li>回归就是预测结果。</li></ul><h2 id="特征抽取">特征抽取</h2><p>抽取特征时，要挑准合适的特征。</p><ol><li>抓准与之紧密相关的特征；</li><li>不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断它们是否喜欢动作片）。</li></ol><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E4%B8%AA%E6%B0%B4%E6%9E%9C.jpg" alt></p><p>  在前面的水果示例中，你根据个头和颜色来比较水果，换言之，你比较的特征是个头和颜色。现在假设有三个水果，你可<strong>抽取它们的特征</strong>。很明显，A 和 B 直观看起来十分相似，但事实上具体多少相似我们还是可以通过 KNN算法 来解决。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.jpg" alt></p><p>  横坐标表示 个头，纵坐标表示 红的程度，因此，我们可以把这三个点用坐标表示出来。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">(2,2)</td><td style="text-align:center">(2,1)</td><td style="text-align:center">(4,5)</td></tr></tbody></table><p>  再利用毕达哥拉斯公式不难算出每两点之间空间距离，并标在图表上。因为 A 与 B 两点之间的距离最短，因此它们俩是最像的，这也印证了之间的直觉。</p><h2 id="回归">回归</h2><p>  假定你在你的老家卖冰棍，由于是夏天，卖地比较火，因此每天都要进货一些新的冰棍。每天的进货量由下面几个指标进行预测。</p><ol><li>天气指数 1~5（数字越大 代表 气温越高）；</li><li>是否是周末或节假日（周末或节假日为 1，否则为 0）；</li><li>有无活动（有为 1，否则为 0）。</li></ol><p>  之后，你测了 1个月的数据，记录了在各种不同的日子里卖出的冰棍数量。在这 30天的容量中，你选出 6天的数据作为样本，如下表所示。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">(5,1,0)</td><td style="text-align:center">(3,1,1)</td><td style="text-align:center">(1,1,0)</td><td style="text-align:center">(4,0,1)</td><td style="text-align:center">(4,0,0)</td><td style="text-align:center">(2,0,0)</td></tr><tr><td style="text-align:center">300根</td><td style="text-align:center">225根</td><td style="text-align:center">75根</td><td style="text-align:center">200根</td><td style="text-align:center">150根</td><td style="text-align:center">50根</td></tr></tbody></table><p>  今天是周末，气温比较高，店里也没有办什么活动，点坐标为（4,1,0）。根据以上数据，你要预测今天大概能卖出去多少根冰棍。只要学过高中数学，就知道这就是个典型的回归问题，但有稍微有点不一样。由于之前说过 KNN算法就是用来解决<strong>编组</strong>和<strong>回归</strong>问题的，因此我们要用 KNN算法来解决。</p><p>利用毕达哥拉斯公式可以算出“今天”与A,B,C,D,E,F点之间的距离，如下所示。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">9</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">5</td></tr></tbody></table><p>  K 取 4 时，与（4,1,0）最近的邻居为 A、B、D 和 E。将这些天售出的冰棍数平均，结果为 218.75。<strong>这就是回归（regression）。</strong></p><h2 id="余弦相似度">余弦相似度</h2><p>  前面计算两位用户的距离时，使用的都是<strong>距离公式</strong>。但在实际工作中，则经常会使用**余弦相似度（cosine similarity）**来量化两位用户的相似程度。余弦相似度不计算两个矢量的距离，而比较它们角度，如果要深入研究，那就是另一个话题了。</p><p>  到这里不妨试着猜想一下开头提及的原理。网易云首先为每个注册的用户生成一个<strong>用户画像（Persona）</strong>，即 将用户的每个具体信息抽象成标签，利用这些标签将用户形象具体化，从而为用户提供有针对性的服务。其中将每个具体信息抽象成标签的过程可能就要用到 <strong>K最近邻算法</strong>，不过这里的空间维数可能要达到千以上的数量级，并且每一维都有<strong>各自的权重</strong>。同理，哔哩哔哩也可能采用这样机制。<br>  但哔哩哔哩和网易云音乐可能没有直接的关系。不妨<strong>假定</strong>在网易云音乐中，用户A 与 用户B 之间的标签十分相似。相似到什么程度呢？一旦 A “喜欢”了一首歌，就会立即反映到当天 B 的推荐歌曲中。接下来的说法要建立在一个前提之上，就是 这种类型的歌曲的听众 可以映射到 哔哩哔哩 的一个较小的“圈子”中。比如，喜欢听 二刺螈 的曲子的人 在哔哩哔哩中可能是混“番剧”这个圈子的。那么就有这种可能，十月新番 在 哔哩哔哩 准时开播，假定 番剧 和 OP 是同时上架的，A 第一时间追了一集之后马上去网易云音乐对 OP 点了“喜欢”。在这之后，B 也追完了，无意打开网易云发现首页上竟然有 自己正在追的动画的 OP，于是在曲子的评论中不禁如下感叹。（当然这不是我，<s>废话。</s>）<br><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/py%E4%BA%A4%E6%98%93.png" alt></p><h2 id="简述机器学习">简述机器学习</h2><p>  KNN算法在神奇的机器学习领域也占有一定的比重。<strong>机器学习</strong>皆在让计算机更聪明。<strong>创建推荐系统</strong>，就是个机器学习的例子。</p><h3 id="OCR">OCR</h3><p>  OCR 指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我们来看一个例子。请看下面的数字。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.jpg" alt></p><p>如何自动识别出这个数字是什么呢？我们当然可以使用 KNN。</p><ol><li>浏览大量的数字图像，将这些数字的特征提取出来。这在机器学习中被称之为<strong>训练（training）</strong>。</li><li>遇到新图像时，提取该图像的特征，再找出它最近的邻居都是谁。</li></ol><p>  与前面的水果示例相比，OCR 中的特征提取明显要复杂得多得多，但再复杂的技术也是基于 KNN 等简单理念的。而这些理念也可用于语音识别和人脸识别。当你将照片你上传到 Facebook 时，它有时候能够自动标出照片中的任务，这正是机器学习在发挥作用。</p><h3 id="创建垃圾邮件过滤器">创建垃圾邮件过滤器</h3><p>  垃圾邮件过滤器用的并非 KNN 算法，而是另一种基本算法——<strong>朴素贝叶斯分类器（Naive Bayes classifier）</strong>。大多数机器学习算法都包括训练的步骤：要让计算机完成任务，必须先训练它。垃圾邮件过滤器也不再例外，因此你需要使用一定量的数据对这个分类器进行训练。垃圾邮件过滤器可以计算出一个任意一个邮件为垃圾邮件的概率，其应用领域与 KNN 相似。<br>  你甚至还可以用朴素贝叶斯分类器对之前提到的水果进行分类：假设有一个又红又大的水果，它是柚子的概率是多少呢？……</p><h3 id="预测股票市场">预测股票市场</h3><p>未来很难预测，由于涉及的变量太多，这几乎是不可能完成的任务。</p><h1 id="最后再介绍十种数据结构和算法">最后再介绍十种数据结构和算法</h1><h2 id="树">树</h2><p>  每当用户登录自己的 B 站 账号时，都要从庞大的数据中去查找，并判断是否存在这样 ID。倘若你要设计 B 站 用户的登陆系统，你会选择什么样的<strong>数据结构</strong>来存储用户 ID 以及 算法用来查找 ID。<br>  如果使用二分查找，并使用极其庞大的数组来存储数据，那么注销和注册一个 ID 将是个极其麻烦的工作。为此，有人设计了一种名为**二叉查找树（binary search tree）**的数据结构，来减轻算法的负担。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><p>  二叉查找树类似于上面这样。这种数据结构形象地表示出来之后长相酷似“树”，因此命名为二叉查找树，其实是一种变异的“链表”。也拜这种结构所赐，使得数据的增删变得极其地方便。其中，树的最顶端被称为<strong>根节点</strong>，其余节点被称为<strong>子节点</strong>。而<strong>对于其中每个节点，左子节点的值都比它小，右子节点的值都比它大。</strong><br>  对于树的查找，其原理与二分查找相似，因此<strong>平均</strong>时间复杂度都为 O(log n)。举个例子，假设我要在上面 5个数据中查找“Maggie”。为此，我首先检查根节点是否为“Maggie”，发现匹配失败之后，发现“Maggie”应该排在“David”的后面，因此我往右边找。“Maggie”应该排在“Manning”前面，于是接着往左边找，最终找到了“Maggie”。<br>  与其它大部分数据结构不同的是，树自己本身是存在<strong>优劣</strong>的，即 有好的“树”，也有“坏”的树。<strong>一颗树中两个分叉的子树数量比例越高，树的性能就越佳。</strong></p><p>👍🌲⬇️</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A5%BD%E7%9A%84%E6%A0%91.png" alt></p><p>👎🌲⬇️</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9D%8F%E7%9A%84%E6%A0%91.png" alt></p><p>  第一棵树正在处于<strong>平衡状态</strong>，此时的最糟的运行时间为 O(log n)。第二棵树处于<strong>非平衡状态</strong>，此时的最遭的运行时间为 O(n)，仿佛整棵树马上就要向左倒下来。由于树与链表相似，都不支持随机访问，二叉查找树处于平衡状态时，平均访问时间为 O(log n)。</p><p>下面给出一下数组和二叉查找树的性能。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">二叉查找树</th></tr></thead><tbody><tr><td style="text-align:center">查找</td><td style="text-align:center">O(log n)</td><td style="text-align:center">O(log n)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(log n)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(log n)</td></tr></tbody></table><p>  此外，还有几种特殊的二叉查找树，如 <strong>B树</strong>、<strong>红黑树</strong>、<strong>堆</strong>、<strong>伸展树</strong> 等，当然这就是另一个故事了。</p><h2 id="反向索引">反向索引</h2><p>这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E4%BB%AC.jpg" alt></p><p>我们根据这些内容船舰一个散列表。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E6%95%A3%E5%88%97%E8%A1%A8.jpg" alt></p><p>  这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜索 hi，在这种情况下，搜索引擎需要检查哪些页面包含 hi。<br>  搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜索 there。你知道，页面 A 和 C 包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散列表，将单词映射到包含它的页面。这种数据结构被称为<strong>反向索引（inverted index）</strong>，常用于创建搜索引擎。如果对搜索感兴趣，从反向索引着手研究是不错的选择。</p><h2 id="傅里叶变换">傅里叶变换</h2><p>  绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained 是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。<br>  这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理。<br>  数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。<br>  使用傅里叶变换可创建类似于 Shazam 这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高。</p><p><strong>接下来的三个主题都与可扩展性和海量数据处理相关</strong>。</p><h2 id="并行算法">并行算法</h2><p>  我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们能够在多个内核中并行地执行！<br>  来看一个简单的例子。在最佳情况下，排序算法的速度大致为 O(n log n)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)。对数组进行排序时，快速排序的并行版本所需的时间为 O(n)。<br>  并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。</p><ul><li><strong>并行性管理开销</strong>。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。</li><li><strong>负载均衡</strong>。假设你需要完成 10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么 50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</li></ul><h3 id="MapReduce">MapReduce</h3><p>  有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce 是一种流行的分布式算法，你可通过流行的开源工具 Apache Hadoop 来使用它。</p><h3 id="分布式算法为何很有用">分布式算法为何很有用</h3><p>  假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过Hadoop来使用MapReduce！<br>  又假设你需要处理一个很长的清单，其中包含 100万个职位，而每个职位处理起来需要 10秒。如果使用一台计算机来处理，将耗时数月！如果使用 100台计算机来处理，可能几天就能完工。<br>  分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：**映射(map)<strong>函数和</strong>归并(reduce)**函数。MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用 MapReduce 只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。</p><h2 id="布隆过滤器和HyperLogLog">布隆过滤器和HyperLogLog</h2><p>  在假设你管理着 Google，要<strong>避免</strong>将用户重定向到恶意网站。你有一个清单，其中记录了恶意网站的 URL。你需要确定要将用户重定向到的 URL <strong>是否在这个清单</strong>中。这些一类型的问题，通常都要涉及庞大的集合。给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用<strong>散列表</strong>。例如，Google可能有一个庞大的散列表，其中的<strong>键是已搜集的网页</strong>。<br>  初始状态时，所有键所对应的值都是“False”。第一次判断 A 网页是否在该集合时，只需或许 A 网页所对应的值即可。随后发现不在这个集合，同时 A 的确是个恶意网页时，就将 “False” 改为 “True”，之后系统再次判断 A 网页是否是恶意网页时，可以先获取其对应的的值即可。散列表的平均查找时间为 O(1)，即查找时间是固定的，这应该是个非常乐观的时间复杂度了。不过 Google 需要建立数万亿个网页的索引，因此这个散列表非常大，需要<strong>占用大量的存储空间</strong>。面临海量数据，我们可以选择非常有创造性的方案——<strong>布隆过滤器</strong>，来解决这种问题。</p><h3 id="布隆过滤器">布隆过滤器</h3><p>  布隆过滤器提供了解决之道。布隆过滤器是一种<strong>概率型数据结构</strong>，它提供的答案有可能不对，但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。具体表现为如下。</p><ol><li>可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。</li><li>不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。</li></ol><p>  布隆过滤器的优点在于<strong>占用的存储空间很少</strong>。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况。</p><h3 id="HyperLogLog">HyperLogLog</h3><p>  HyperLogLog是一种类似于布隆过滤器的算法。HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。<strong>面临海量数据且只要求答案八九不离十时，完全可以考虑使用概率型算法</strong>。</p><p><strong>接下来的两个话题都与加密算法有关</strong>。</p><h2 id="SHA算法">SHA算法</h2><p>  之前介绍的散列函数都是将<strong>键</strong>直接映射到内存地址上。而另一种散列函数，安全散列算法（secure hash algorithm，SHA）函数，则是将<strong>字符串类型</strong>的<strong>键</strong>直接映射到一个较短字符串上。比如 “hello” 这个字符串通过 <code>SHA256</code> 加密后的结果为<code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code></p><p>下面简述安全散列算法的<strong>安全</strong>体现在哪里。</p><ol><li>这个散列函数不会产生冲突，因此不会出现因为明明输错密码还能够成功登录的情况。</li><li>这个散列函数没有反函数，意味着不能直接反破译出密码，因此密码校验都是用 SHA 加密结果进行比对。</li><li>就算原字符串只改变了一个字符，最终的 SHA 结果也会截然不同。因此攻击者无法通过比较散列值是否类似来破解密码。这时就称这种散列函数对<strong>全部敏感</strong>。<ol><li>“hellow” <code>SHA256</code> 加密结果为<code>d0bc381952d0827f36467818a9560eb5eb6fda8a64a422aa21fcda3f2263e8b4</code></li><li>“hella” <code>SHA256</code> 加密结果为<code>70de66401b1399d79b843521ee726dcec1e9a8cb5708ec1520f1f3bb4b1dd984</code></li><li>“hell” <code>SHA256</code> 加密结果为 <code>0ebdc3317b75839f643387d783535adc360ca01f33c75f7c1e7373adcd675c0b</code></li></ol></li></ol><p>  SHA除了核对密码外，还可以<strong>判断文件是否为同一文件</strong>，即 将两个文件的 SHA 值计算出来进行比对即可。</p><p>  SHA实际上是一系列算法：SHA-0 , SHA-1 , SHA-2 和 SHA-3。其中，SHA-0 和 SHA-1 已被发现存在一些缺陷。如果你要用SHA算法来计算密码的散列值，请使用 SHA-2 或 SHA-3。当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。</p><h3 id="Simhash">Simhash</h3><p>  simhash 是对局部敏感的散列函数，表现为如果你对字符串做细微的修改，Simhash 生成的散列值也只存在细微的差别。这时，你可以通过比较散列值来判断两个字符串的相似程度。</p><ul><li>Google 使用 Simhash 来判断网页是否已搜集；</li><li>老师可以使用 Simhash 来判断学生的论文是否是从网上抄的。</li></ul><h2 id="Diffie-Hellman-密钥交换">Diffie-Hellman 密钥交换</h2><p>  简单的加密算法就不再赘述了，因为加密程度比较低，因此非常容易暴力破解出来。Diffile-Hellman 算法，简称 DH 算法。它有以下两个优点。</p><ol><li>双方无需知道加密算法。他们不必会面协商要使用的加密算法。</li><li>要破解加密的消息比登天还难。</li></ol><p>  DH 算法加密时会使用到两种密钥：<strong>公钥和私钥</strong>。顾名思义，公钥就是公开使用的密钥，被第三者获取了也无所谓。而私钥，则是最终解密的关键。具体 DH 算法是如何执行的，可以去 B 站搜索 <strong>av73112181</strong>，这个视频中用类比的方式比较直观地演示了密钥交换过程，个人也觉得既优雅又不难理解。DH 算法是算法加密的先驱者，它的后辈 <strong>RSA 算法</strong>依然在被广泛使用，当然这就是另一个故事了。</p><h2 id="线性规划">线性规划</h2><p>  但愿读者还能想起来自己高中还确实学过<strong>线性规划</strong>这么个东西。线性规划就是为了不断优化，最终达到最优解的工具，这与算法中优化的思想不谋而合，因此线性规划本质上也是可以算作是算法。所有的<strong>图算法</strong>都可使用线性规划来实现。线性规划是一个宽泛得多的<strong>框架</strong>，而图问题只是其中的一个子集！因此把如此牛掰的算法放最后讲也不是没有道理的。线性规划使用Simplex算法，不过这个算法很复杂，详细介绍就又称另一个故事了。</p><h1 id="结语">结语</h1><p>  希望你可以在这个饱受争议的领域中，走出那个连曾经那个自己都不敢想象的路途，浮躁的情绪沉淀下来或成为你的决心。希望我可以一直娓娓道来曾经我还未讲述的故事，当然这就是另一个故事了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一开始的 Java 语法学习①</title>
      <link href="/2020/01/30/%E4%BB%8E%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%91%A0/"/>
      <url>/2020/01/30/%E4%BB%8E%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%91%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>研究了 Java 中的一些基本特性及语法，诸如 Java 中的对象和类，基本类型，运算符，控制流等</strong><br>v1.2.20200222</p><a id="more"></a><h1 id="阅前须知">阅前须知</h1><p>  这是一个从一开始学习 Java 的文章，没有过多的关于语法方面的内容，非快餐向（欲速则不达），仅供参考。本篇文章需要读者对面向对象有个基本的概念的认知。本篇文章所参考的书籍为&quot;OnJava8&quot;，这是《Java 编程思想(第四版)》的作者在 2016年基于 <strong>JDK 1.8</strong> 所新编的 Java 学习教材，因此又被称为《Java 编程思想(第五版)》。我猜测点开这篇文章的读者一般是，抱着入门 Java 的心态学习 OnJava8 这本书，但同时希望有人已经写过类似于学习笔记一样的博文来加深理解，或者是书中的哪一块有点弄不太懂，希望有个更清楚的解释。这样的人我相信这个&quot;读书笔记&quot;应该是非常适合你的。不过还是要提一点的是，除非是老手(不过老手也不会看这篇博文就是了)，一定要在书中至少阅读一遍你想要学的章节，然后再来考虑看不看这篇文章，这个博文只能是起到辅助作用，多读几遍书远比看几百通博文的效率来的高多了，免得浪费更多的时间。<br>  之所以选用这个系列主要是因为久仰大名了，《Java 编程思想(第四版)》甚至被有些人索性称作是 Java 书籍中的圣经，那么对初学者有这么一本权威性的书籍固然是好的，但问题是零基础小白想吃透这本书难度还是不小的。鉴于本人也确实没什么经验，因此在读这本书的时候，我打算把我认为比较基础性、启发性的内容用自己的话提出来，省略掉书中繁琐的例子，整体偏理论风一点，实践部分较少，我知道这对一门工科的学习是不应该的，所以看的同时还要多敲敲代码，找一个上手简单的项目练练手是最好的。所以这个博文的标题叫从一开始而不是从零开始，因为不管是 OnJava8 的读者也好，这篇博文的读者也罢都确实需要一定量的底子，说白了就是计算机素养。<br>目前的我的确不能完全 hold 住本书，但是后期每提升一个阶段我会尝试用更高的角度再来看看这篇博文，我能看得出来的有能改进的地方我就会尽力修改掉（点进文章之前标题下面会有类似于版本号的数字就是我版本迭代的标识) 。<br>文中会经常出现<strong>标黑</strong>和<code>高亮</code>的词语或短句，前者主要是一些计算机术语或是想要表示强调，后者则是英文的术语或者符号以及表示强调时使用。<br>  以下是原书作者在&quot;OnJava8&quot;开头整本书的简介，更多内容请参考<a href="https://lingcoder.github.io/OnJava8/#/sidebar" target="_blank" rel="noopener">原书在线中文译版</a>。</p><blockquote><p>  Java 本身是门派生语言，是在 C++ 基础上新增和删除了一些功能。其中最核心的变化就是加入了“虚拟机”和“垃圾回收机制”，此外，Java 还在其他方面推动了行业发展。例如，现在绝大多数编程语言都支持文档注释语法和HTML 文档生成工具。<br>  把一切事物都抽象成对象不仅是一项不必要的负担，同时还会招致许多设计朝着不好的方向发展。但“对象”的概念依然有其闪光点。固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；相反，完全逃避“对象”的概念似乎同样太过苛刻。<br>  编程语言不是神造物，因此难免会有设计缺陷，即便是当下普及度最广的 Java，学习时我们应该也要带着<strong>批判性的思维</strong>去学习。正因为 Java 是<strong>严格向后兼容</strong>的，因此有些设计缺陷到现在还有在保留，如果不去正式这些错误，而反而去包庇则是相当不可取的行为。<br>  Java 语言曾规划设计的许多功能并未按照承诺兑现。本书中，我将尝试解释这些原因，力争让读者知晓这些功能，并明白为什么这些功能最终并不适用。这无关 Java 是一种好语言或者坏语言，一旦你了解了该语言的缺陷和局限性，你就能够：</p><ol><li>明白有些功能特性为什么会被“废弃”；</li><li>熟悉语言边界，更好地设计和编码。</li></ol><p>阅读本书需要读者对编程有基本的了解:</p><ul><li>程序是一系列“陈述（语句、代码）”构成；</li><li>子程序、方法、宏的概念；</li><li>控制语句（如 if），循环结构（如 while）。</li></ul><p>  甲骨文公司已经提供了免费的标准 JDK 文档。除非有必要，否则本书中将不再赘述 API 相关的使用细节。使用浏览器来即时搜索最新最全的 JDK 文档好过翻阅本书来查找。只有在需要补充特定的示例时，我才会提供有关的额外描述。</p></blockquote><p>  由于英文原版书的页数已经超过 3k page，因此我不打算把我所有内容全部写在一篇博文上，会分成若干篇进行阶段式总结，并且每篇文章的最后都会对这一阶段抽象出来做一个高度总结。工科的学习除了理论知识外还强调自己亲自落地实践，因此还后期阶段还可能会在 GitHub 上扒几个小练手的项目，到时候在针对那个项目再开一篇博文。顺带一提，之后会针对原书的第一章，即对象导论中的内容单开一篇博文，当然这都是很后面的事情了。</p><h1 id="伊始">伊始</h1><p>  首先，我们首先要达成这样一个共识：<strong>代码是用来读的</strong>。读的不是语法，而是背后的<strong>想法</strong>。不要面向机器编译，要面向人类交流，好的代码它的可读性一定要强，这样才能满足团队以及维护的需要。至于如何写出即规范又好读的代码可以参考相关书籍，诸如编程珠玑，编程之美，编写可读代码的艺术等。<br>  所有的编程语言都会操纵内存里面的元素，而有时我们程序员又会去直接或间接地干预这些内存中的元素。在 Java 中，万物皆为对象，但往往不是直接操纵对象本身，而是对象的<strong>引用</strong>，这就类似于电视和遥控器之间的关系。创建引用时，我们需要先声明引用的<strong>类型</strong>以及<strong>标识符</strong>，后为这个引用<strong>初始化</strong>，之后这个引用会存储对象在内存中的地址，否则直接使用没有指向任何对象的引用时会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"114514"</span>;</span><br><span class="line"><span class="comment">// 每个类型都有自己独有的初始化方式，Java里使用带双引号的文本内容来代表字符串型。</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1919810"</span>);</span><br><span class="line"><span class="comment">// 我们还可以使用操作符 new 来新建一个对象实例来初始化引用。</span></span><br></pre></td></tr></table></figure><h2 id="数据存储">数据存储</h2><p>  Java 中的数据可分为两类：基本数据类型和引用数据类型。其中基本数据类型又可分为 8 种，分别是：<code>boolean</code>(布尔型)、<code>char</code>(字符型)、<code>byte</code>(字节型)、<code>short</code>(短整型)、<code>int</code>(整型)、<code>long</code>(长整型)、<code>float</code>(单精度浮点型)、<code>doble</code>(双精度浮点型) 。而引用数据类型数据类型又由<strong>类引用类型</strong>、<strong>接口引用类型</strong>、<strong>数组引用类型</strong>构成。<br>![](从一开始的 Java 语法学习①/Java数据类型.png)</p><p>下面会简单地解释为什么 Java 会将数据分为两大类型，这就跟数据在硬件中储存的位置有关了。<br>  我们在上面的代码示例中新建了一个引用并且实例化了一个对象，那么这些数据都存储在哪里呢？我们简单大概了解一下。</p><ol><li><strong>寄存器(Registers)</strong>，它是存取速度最快的存储区域，数量非常少，位于 CPU 内部。</li><li><strong>栈内存(Stack)</strong>，它位于常规内存 <strong>RAM</strong>(Random Access Memory，随机访问存储器)中，速度仅次于寄存器。我们使用<strong>栈指针</strong>来管理内存，栈指针上移释放内存，下移分配内存。编译器需要精确知道栈内存中的每个数据的生命周期，限制了程序的灵活性。<strong>通常</strong>变量和引用会存储在栈内存中，而对象实例则会存储在堆内存中。</li><li><strong>堆内存(Heap)</strong>，它是一种 RAM 区域的通用的<strong>内存池</strong>，所有 new 出来的对象实例无一例外地都存在这里。编译器也没必要知道对象的声明周期，因此这里的数据没有栈内存数据的限制，更具灵活性。但取而代之的 debuff 则是分配和清理，即存取堆内存中的数据相较于栈内存比较低效。</li><li><strong>常量存储(Constant storage)</strong>，因为常量值永远不会改变，可直接放在程序代码中。考虑到安全性，可以将常量值置于只读存储器 ROM(Read Only Memory) 当中。</li><li><strong>非 RAM 存储(Non-RAM storage)</strong>，是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM 的对象，使得在程序未运行以及脱离程序控<br>制后依然存在。常见的两个例子：<ol><li>序列化对象：对象被转换为字节流，通常被发送到另一台机器；</li><li>持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。</li></ol></li></ol><h3 id="基本数据类型的存储">基本数据类型的存储</h3><p>  <code>new</code> 关键字所创建的对象实例一律存储在堆内存。基本数据类型在 Java 中的使用频率很高，而且这种对象往往小并简单，如果还把这种对象存储在效率比较低的堆内存中实在不太划算，于是为了方便程序员的同时也为了提高小于， Java 采用了其它方案。想进一步了解可以移步至<a href="https://www.cnblogs.com/Latiny/p/8099581.html" target="_blank" rel="noopener">这篇文章</a>。主要讲的就是两个事实：</p><ol><li>对于<strong>局部变量</strong>，都会先在栈中分配一块内存，对于基本数据类型来说，这块区域包含的是它的字面值。而对于引用数据类型，这块区域包含的是指针，也就是堆内存中的地址；</li><li>对于<strong>成员变量</strong>，都会存储在堆内存或者方法区中。</li></ol><p>​顺带一提，这篇文章中除了讲到了两种类型的存储差异外，还提到了运算符 <code>==</code> 和 <code>equals()</code> 方法的以同，其实这两个的区别不大，因为 Object 类里面的 <code>equals()</code> 方法内部就是用 <code>==</code> 来实现的，只不过在一些类对 <code>equals()</code> 进行了重写，因此这样的 <code>equals()</code> 就有了特殊的功能而已。<br>  如果你执意要将基本数据类型对象存储在堆内存，那就要使用到基本类型对应的<strong>包装类</strong>，比如基本类型 <code>int</code>  的包装类就是 <code>integer</code>，之后再根据这个对象 <code>new</code> 一个对象即可。Java 确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。</p><table><thead><tr><th style="text-align:center">简单类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr></tbody></table><h3 id="数组的存储">数组的存储</h3><p>  数组<strong>是</strong>存储在单个连续的内存块中的相同的数据类型的变量集合。数组<strong>不是</strong>储存在多个离散的内存块中的不同的数据类型的变量的集合，注意两个句子用词上的区别。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。值得一提的是 Java 中的数组使用之前必须先初始化，即给数组中的每个元素分配元素赋初始值。<br>  在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。<br>  当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 <code>null</code> 。在使用该数组之前，我们必须为每个引用指定一个对象。如果我们尝试使用为 <code>null</code> 的引用，则会在运行时报错。<br>  我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。更多详细内容会在数组章节中解释。<!--这两段需要修正，描述不清。--></p><h2 id="对象清理">对象清理</h2><p>  我们知道变量和引用都是储存在栈内存的，而 Java 需要精确知道每个在栈内存中的数据的<strong>生命周期</strong>，而生命周期则是由<strong>作用域</strong>严格控制的，Java 中作用域又由 <code>{}</code> 的<strong>相对位置</strong>确定。Java 作用域可相互嵌套，内层作用域不允许再定义外层已经定义过的变量，否则会报错。<br>  值得一提的是，Java 和 C/C++ 同属<strong>自由格式</strong>的编程语言，因此我们可以通过<strong>适当的空格</strong>以及<strong>缩进</strong>使书写出来的代码更具可读性。<br>  与栈内存不同的是，堆内存中的对象的生命周期不会受到作用域的影响，但它的引用会。一旦引用所在作用域结束后，若没有一个其它的引用去指向这个对象，那么 Java 的垃圾收集器会将释放其内存，供其它新对象所用，防止产生在类似 C/C++ 中的“内存泄漏”问题。</p><h2 id="类的创建">类的创建</h2><h3 id="字段">字段</h3><p>  新建一个类时，定义变量和引用的部分叫做<strong>字段(field)</strong>，你需要对其中每一个变量及引用进行初始化。如果没有对基本类型变量初始化还好说，因为最后 Java 会给你赋<strong>零值</strong>。但类的<strong>方法内部新建的变量</strong>都需要初始化，否则 Java 直接报错，在这一点 C++ 反而做的更好，因为它只会提示警告。</p><h3 id="方法">方法</h3><p>  在其它大多数语言中会使用术语<strong>函数(function)<strong>用来明命子程序，而在 Java 中则是使用</strong>方法(method)</strong>，表示“做某事的方式”。<br>  在 Java 中，方法决定<strong>对象消息的接收</strong>。<!--这一句可能需要修正，概念不清-->方法的基本组成部分包括<strong>名称</strong>、<strong>参数列表</strong>、<strong>返回类型</strong>、<strong>方法体</strong>。方法名和参数列表统称为<strong>方法签名(signature of the method)</strong>。其中，参数列表必须明确每个参数的类型、名称、个数以及顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[返回类型][方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">   <span class="comment">// 方法体   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Java 中的方法<strong>只能被有执行权限的对象</strong>所调用，若对象错误地调用方法，则编译时报错。这种正确调用方法的行为被称为<strong>向对象发送消息</strong>，是 OOP 的核心动作。<!--这里可能需要补充些要点--></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象引用].[方法名](参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3</span>)；</span><br></pre></td></tr></table></figure><h2 id="类的导入">类的导入</h2><p>  在 IDEA 中，没有像 eclipse 一样的工作空间，取而代之的是<strong>项目</strong>。这个项目下又分有复数个<strong>功能模块</strong>。一个功能模块下又由复数个<strong>类库</strong>或者叫作<strong>包</strong>。一个包里面又装有由非常多的类。当项目变得复杂时，各种各样的包如同一团乱麻。因此 Java 采用了全新的方式来避免包或者类重名的问题——反向使用网络域名，因为网络域名通常是唯一的。比如我可以将我的 <code>foibles</code> 类库命名为 <code>com.mindviewinc.utility.foibles</code> 。其中， <code>.</code> 代表子目录的划分，并且要求包名都是小写的。以上解决方案意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。这样如此，Java 就可可以防止名称冲突。<br>  使用反向URL 将命名空间与文件路径相关联不会导致BUG，但它却给源代码管理带来麻烦。例如在 <code>com.mindviewinc.utility.foibles</code> 这样的目录结构中，我们创建了<code>com</code> 和 <code>mindviewinc</code> 空目录。它们存在的唯一目的就是用来表示这个反向的URL。<!--这两段绝对没有说清楚，需要补充要点--><br>  空目录填充了深层次结构，它们不仅用于表示反向URL，还用于捕获其他信息。这些长路径基本上用于存储有关目录中的内容的数据。对于生产级的 Java 代码，你必须使用专门为此设计的 IDE 来管理代码。例如<code>NetBeans</code>，<code>Eclipse</code> 或 <code>IntelliJ IDEA</code> 。实际上，这些 IDE 都为我们管理和创建深层次空目录结构。<br>  为了防止类名称冲突，你需要使用 <code>import</code> 关键字来导入你将要使用的类。此外，你还可以使用通配符 <code>*</code> 来一次性导入类库中所有可导入的类，而不用注意显示导入，但不推荐这么做。<!--这一段概念可能错了--></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 针对性地导入 ArrayList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 导入 util 类库下所有可导入的类</span></span><br></pre></td></tr></table></figure><h2 id="静态字段与方法">静态字段与方法</h2><p>  我们知道 OOP 中，实现所有动作基本都要靠对象之间的消息来完成。也就是说你想用一个类的字段的某个数据或者某个类中的方法，你就必须要实例化出来一个对象并且为其分配一个内存才行。Java 中，一旦被 <code>static</code> 关键字所修饰的字段或方法时，这些字段或方法就不再依赖于任何特定的对象实例而存在。也就是说，即使我们从未创建过该类的对象，我们仍然可以调用其<strong>静态方法</strong>或访问其<strong>静态字段</strong>。不管新建多少个对象它在内存中永远只占一份的空间，即这些对象之间是共享这份数据的。这些静态字段和静态方法有时也被称为<strong>类数据(class data)</strong> 和<strong>类方法(class method)</strong> 因其只依赖于类而与类的对象无关得名。<br>  我们有两种访问类数据或调用类方法的方式：通过类名引用或者通过类的对象来定位。不过还是推荐用类名引用，因为这能一定程度上显示出这种“静态”的意义，而且也更为方便。<code>static</code> 关键字的这些特性对于应用程序入口点的 <code>main()</code> 方法尤为重要。<!--如何理解这句话的真正的意思？--></p><h2 id="小结">小结</h2><p>综合以上的知识来说我们就可以解释 Java 里面的打印语句为什么是下面这样的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"A String of Things."</span>)</span><br></pre></td></tr></table></figure><p>  我们此时需要查阅 Java 8 的 API 文档，顺着文档找即可。首先 Java 中有个叫 <code>java.lang</code> 的类库，这个类库会<strong>隐式地</strong>包含在<strong>每个</strong> Java 代码文件中，因此我们不需要去显式地去导入它就能直接用类库里面地模块了。java.lang 这个库中有个类叫 <code>System</code> 这个类的字段中有一个静态引用 <code>out</code> 指向了 <code>PrintStream</code> 类型的对象。然后这个对象的方法中就有很多参数列表不同但方法名相同的方法 <code>println()</code>。<br>  Java 可怕的地方在于它拥有一个庞大的标准库资源，像刷算法用的 C++ 的 STL 库一样，功能十分的强大，这个标准库也要像 STL 一样单独拿出来学好一阵子，因此在这里就不做过的讲解，英语能力比较 <code>nice</code> 的同学可以直接去看原版 API 文档，收获肯定不少，之后也可能会出 Java 标准库或者第三方库中使用频率较高的一些类或方法或者特性都可以开几篇博文讨论讨论。<br>  每个 java 源文件中允许有多个类。同时，<strong>源文件的名称</strong>必须要和<strong>其中一个类名</strong>相同，否则编译器将会报错。每个<strong>独立的</strong>程序应该包含一个 <code>main()</code> 方法作为程序运行的入口。其方法签名和返回类型如下。<!--待补充和确认概念问题--></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// main 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  简单地解释下为什么一个独立的程序必须包含一个 main 方法吧。首先 main 方法必须要写在类里面。之后这个类会被 JVM 调用，找到程序中的 main 接口再调用，因此这个接口必须是 <code>public</code> 的。再者，既然是 JVM 直接调用该方法那么这个 main 方法只能是 <code>staitc</code> 的。另外，JVM 并不需要 main 方法给它返回什么数据，只希望 main 方法能够执行，因此需要 <code>void</code> 修饰。最后执行 Java 命令时需要传入 String 类型的数组参数。更为详细的内容可以学习《深入理解 Java 虚拟机》这本书。<br>  我们在创建类时，类型需要采用帕斯卡命名法，有时也叫大驼峰命名法，即每个单词的首字母都要大写。而其它的命名一般都采用小驼峰命名法，即第一个单词的首字母小写，其他字母的首字母大写，以上两种其实都是一种编码规范风格。<!--这一段有待补充和修正--></p><h1 id="基本类型与字面值">基本类型与字面值</h1><p>  字面值，顾名思义，就是字面上原原本本呈现出来的数据，所见即所得，有时简称其为<strong>值</strong>。它常用于表示一些<strong>固定的值(fixed value)</strong>。不同的基本数据类型之间的字面值的形式都会有所不同。一般地，可分为整形字面值、浮点字面值、字符和字符串字面值、特殊字面值等，这其中字符串类型严格来说是引用数据类型，不过一起说明影响不大。</p><h2 id="整型字面值">整型字面值</h2><p>  Java 中的整型一共有四种——<code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code>，Java 的整数数值默认指的就是 <code>int</code> 型。整型字面值在基数不超出指定类型的大小范围时都可以用二进制、八进制、十进制、十六进制表示。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">占用内存</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1个<strong>字节</strong></td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2个<strong>字节</strong></td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4个<strong>字节</strong></td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8个<strong>字节</strong></td></tr></tbody></table><h2 id="浮点字面值">浮点字面值</h2><p>  Java 中，浮点型可分为 <code>float</code> 型和 <code>double</code> 型，其字面值类似于小数，可在字面值最后加上 <code>F</code> 或 <code>f</code> 来表示 <code>float</code> 型，如果不加或者加 <code>D</code> 或 <code>d</code> 则表示双精度型，即 <code>double</code>  型。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">占用内存</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">32位</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64位</td></tr></tbody></table><p>  Java 同样也支持<strong>科学计数法</strong>表示浮点字面值，跟大部分语言一样也是用 <code>e</code> 这个自然对数的基数来表示 10 的几次幂。这个其实是 FORTRAN 语言最先带的头，然后就一直顽固地延续下来了。<br>  值得一提的是，编译时如果遇到浮点字面值并且带指数，那么会认为这是个 <code>double</code> 类型处理。因此，如果想将带指数的浮点数赋值给 <code>float</code> 类型，别忘了在字面值后面加个 <code>F</code> 或者 <code>f</code> 。<br>  不知道但想了解浮点值在内存中的存储形式或者 float 和 double 的取值范围和精度范围的可移步至<a href="https://www.zhihu.com/question/46432979/answer/221485161" target="_blank" rel="noopener">大佬的解释</a>，个人觉得解释的还是挺清楚的，至少有收获。</p><h2 id="超高精度数值">超高精度数值</h2><p>  在 Java 中有两种类型的数据可用于高精度的计算。它们是 <code>BigInteger</code> 和 <code>BigDecimal</code> 。尽管它们大致可以划归为<strong>包装类型</strong>，但是它们并没有对应的基本类型，像包装类型 <code>Integer</code> 所对应的基本类型就为 <code>int</code>，包装类型 <code>Float</code> 所对应的基本类型就为 <code>float</code> 。<br>  这两个包装类包含的方法提供的操作与对基本类型执行的操作相似。也就是说，能对 <code>int</code> 或 <code>float</code> 做的运算，在 <code>BigInteger</code> 和 <code>BigDecimal</code> 这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。<br>  <code>BigInteger</code> 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。<code>BigDecimal</code> 支持任意精度的定点数字。例如，可用它进行精确的货币计算。<br>  关于这两个类的详细信息，请参考 JDK 官方文档。</p><h2 id="字符及字符串字面值">字符及字符串字面值</h2><p>  字符类型只有 <code>char</code> 型，字符串类型只有 <code>string</code> 型，字面值上的区别就在于前者使用 <code>''</code> 将字面值括起来，后者则用 <code>&quot;&quot;</code> 将字面值括起来。字面值可以直接从键盘上键入相应的字符，但有些字符你是在键盘上找不到的，比如“换行符”，好在 Java 提供了转义序列的功能。</p><h3 id="转义字符">转义字符</h3><p>  转义序列，又叫转义字符，顾名思义就是将你所键入的字符序列转化成另一个字符。其中的键入的字符序列中，可支持的有<strong>几个有限的英文字符</strong>以及<strong>八进制或十六进制的整型</strong>。理论上你可以用一个转义十六进制数表示 UTF-16 字符集中任意一个字符。<br>  此外，<strong>String 类</strong>支持 <code>+</code> 和 <code>+=</code> 运算符。运算时，操作数中只要有一个是 string 型，那么所有的操作数都将转化为字符串型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, z = <span class="number">2</span>;</span><br><span class="line">String s = <span class="string">"x, y, z "</span>;</span><br><span class="line">System.out.println(s + x + y + z);<span class="comment">// 输出 x, y, z 012</span></span><br><span class="line">System,out.println(s + (x + y + z));<span class="comment">// 输出 x, y, z 3</span></span><br><span class="line">s += <span class="string">"test"</span>;</span><br><span class="line">System.out.println(s)<span class="comment">// 会输出 x, y, z test，而不是 testx, y, z 。</span></span><br></pre></td></tr></table></figure><p>  值得一提的是，我们可以利用 Java 也将 <code>&quot;&quot;</code> 这样的一个空字符串也是为 String 型的特点来隐式转换一些类型，比如 <code>int x = 0; System.out.println(&quot;&quot; + x);</code> 这样 <code>x</code> 就自动地转化为 String 型了(当然本质上还是没变，因为传参时只传了 x 的副本)，这样就避免使用了繁琐的显式调用方法 (比如这里可以使用 <code>Integer.toString()</code> )。<br>  并且要注意，使用 <code>+=</code> 连接字符串时的公式为 <code>String0 += String1</code> 实际上是 <code>String0 = String0 + String1</code> ，而不是 <code>String0 = String1 + String0</code> ，注意不要搞反了，字符串连接不满足加法交换律。因此，当你的字符串太长以至于一行塞不下去，但是你又想只用一行来表示，那么可以使用 <code>+</code> 运算符来连接两个字符串，Java 并没有提供续行转义序列。<br>  注意 <code>%n</code> 的使用。熟悉 C 风格的程序员可能习惯于看到 <code>\n</code> 来表示换行符。问题在于它给你的是一个“Unix 风格”的换行符。此外，如果我们使用的是Windows，则必须指定 <code>\r\n</code> 。这种差异的包袱应该由编程语言来解决。这就是 Java 用 <code>%n</code> 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 <code>System.out.printf()</code> 或 <code>System.out.format()</code> 时。对于 <code>System.out.println()</code>，我们仍然必须使用 <code>\n</code>；如果你使用 <code>%n</code>，<code>println()</code> 只会输出 <code>%n</code> 而不是换行符。<!--这一段到底在说些什么东西啊--><br>  结尾的两个方法 <code>printBinaryInt()</code> 和 <code>printBinaryLong()</code> 分别操作一个 <code>int</code> 和 <code>long</code> 值，并转换为二进制格式输出，同时附有简要的文字说明。除了演示 <code>int</code> 和 <code>long</code> 的所有位运算符的效果之外，本示例还显示 <code>int</code> 和 <code>long</code> 的最小值、最大值、+1 和 -1 值，以便我们了解它们的形式。注意高位代表符号：0 表示正，1 表示负。上面显示了 <code>int</code> 部分的输出。以上数字的二进制表示形式是带符号的补码（2’s complement）。<br>  此外，在 <code>char</code> 基本类型的包装类 <code>java.lang.Character</code> 中，不仅包含了基本类型 <code>char</code> 的值，还封装了一些有用的方法，比如静态方法 <code>isLowerCase()</code> 来判断字符是否为小写。</p><h2 id="null-字面值">null 字面值</h2><p>  之后会具体提到这个特殊的字面值，<!--别之后了，麻烦现在就补充一下-->对初始化变量特别有用。不过顺带一提，初始化变量也是个好习惯。</p><h2 id="数值型字面值中的下划线">数值型字面值中的下划线</h2><p>  在 JDK 7 开始的新特性中，可以在数值型字面值，即整形字面值和浮点字面值的内部插入 <code>_</code> 来分隔数字，但不影响其结果，使结果更清晰易于程序员阅读。当然我们还要考虑使用 <code>_</code> 时的合法性。具体如下：</p><ol><li>仅限单 <code>_</code>，不能多 <code>-</code> 连续相连；如 int test = 12___34 就是非法的;</li><li>数值开头和结尾不允许出现 <code>_</code>；如 int test = _1234 或 float test = 1.234_f 就是非法的；</li><li>F , D 和 L 的前后出不允许现 <code>_</code>；</li><li>二进制前导 b 和十六进制 x 前后不允许出现 <code>_</code>。</li></ol><h2 id="类型转换">类型转换</h2><p>​我们再讨论一个话题——<strong>类型自动转换</strong>。基本类型在一些适当的情况下可以自动从较小的类型转型为较大的类型，首先要认清两个前提：</p><ol><li>Java 中任何有可能数值精确度的行为都视为非法，这是从类型上考虑而不是数值上考虑；</li><li>手动输写出来的数值默认都为 <code>int</code> 型 ( 这条上面也有说过 )。</li></ol><p>综合我在 IDEA 上面的实验以及网上各类博文的各种解释，给出事实：</p><ol><li>只要是 <code>byte</code> , <code>short</code> , <code>char</code> 这种精确度比 <code>int</code> 精确度低的类型在进行<strong>数值运算</strong>，即任何算术或按位操作时无条件类型提升为 <code>int</code> 型，并且结果值的类型为 <code>int</code> 。若想重新使用较小的类型，必须使用强制转换；</li><li>进行 <code>byte</code> , <code>short</code> , <code>char</code> 这种精确度比 <code>int</code> 精确度低的类型赋值时，当且仅当等号右边只有数值或全为数值运算时才算合法，比如 <code>byte test = 1 + 2</code>——这是上面第一个前提的唯一一个例外；</li><li>小类型可类型提升为大类型，表现为小类型与大类型自由运算时，小类型<strong>自动</strong>转化为大类型后保证所有类型均为大类型，从而进行合法运算。例如，float 型和 <code>double</code> 型相乘，结果为 <code>double</code> 型；<code>int</code> 和 <code>long</code> 相加，结果为 <code>long</code> ；</li><li>由于数值默认都是 <code>int</code> 型，因此赋值 long 类型的变量时，由于 int 的大小限制需要手动在字面值最后加一个 <code>L</code> 或 <code>l</code> 来表明这个数值将会是 long 型，推荐加 <code>L</code> 又便于和数字 <code>1</code> 区分开来。；</li><li>向一个方法传参时，如果实参类型小于形参类型，那么将自动类型提升为形参类型。</li></ol><p>  有意思的是你在做看似合法的运算时，所得的结果完全有可能超出指定类型。比如 <code>long lg = -2147483648 - 2147483647;</code> ，打印出 <code>lg</code> 的之后发现字面值为 <code>1</code>。由于 Java 是个静态语言，假定 1 字节内存空间为一个单元，那么 <code>int</code> 类装不下这么大的数值之后会再占用旁边的一个内存单元用来储存溢出的部分位数，但编译器还是只读原来的 4 个单元的数值。诚然，Java 是优秀的，但是还不足够优秀。<!--这段还可以解释的更清楚一些。--><br>  使用整型数值类型时，有时显示其二进制形式会很有用。<!--为什么会很有用没解释-->这其实很容易实现，只要调用其静态的 <code>toBinaryString()</code> 方法即可。但是请注意，若将较小的类型，比如 <code>byte</code> , <code>short</code> , <code>char</code> 作为参数传递给 <code>Integer.tobinarystring()</code> 时，类型将自动转换为 <code>int</code> 。<br>  <strong>除了布尔类型</strong>的数据，Java 允许任何基本类型的数据转换为另一种基本类型的数据。类型转换大体上可分为显式转换和隐式转换两种，我们可以在程序未自动转换时显式、强制地使此类型发生转换，只要在字面值或者变量的左侧加上一个 <code>()</code> ，里面再填入你想要强制转换的类型即可。但大多数情况下，这种显式强制转换是没有必要的，因为 Java 会判断在“合适”的时机去自动地帮助我们转换成合适的类型。<br>  但是类型转换时要满足一个前提：<strong>保证不会造成任何信息的丢失，或者影响字面值的精度</strong>。形如 <code>int</code> 转化为 <code>long</code> 的操作我们称之为<strong>向上转换(Widening conversion)</strong>，因为它是一个容量小的数据类型转换成容量较大的类型，这当然没问题，好比将装在 100ml 容量的矿泉水倒入到 1L 的瓶子中。 但是反过来就不一定可行了，这要取决于大瓶子中水的体积，这就是<strong>向下转换(Narrowing conversion)</strong>，这种操作可能会发生信息丢失的危险。<br>  值得一提的是，如果我们将强制将 <code>float</code> 转换为 <code>int</code> 会发生什么，比如将 <code>29.7</code> 转成 <code>int</code> 型。答案是 <code>29</code> ，也就是说 Java 会直接截断小数位。如果你想要四舍五入，你可以使用 <code>java.lang.Math</code> 的 <code>round()</code> 方法。<br>  此外，类是不能进行类型转换的。为了将一个类转换为另一个类型，需要使用特殊的方法 (后面将会学习到如何在父子类之间进行向上/向下转型，例如，“橡树”可以转换为“树”，反之亦然。而对于“岩石”是无法转换为“树”的) 。<!--这个解释地再清楚一些--></p><h2 id="自动装箱与自动拆箱">自动装箱与自动拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line">Integer demo = <span class="number">1145148101919</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> test = demo;</span><br></pre></td></tr></table></figure><p>​上面就是 Java 自动装箱拆箱的简单实例。我们知道基本数据类型与它的包装类是一一对应的，人们认为基本类型的包装就是包装类，因此基本数据类型转换成包装类的过程就像是 <code>boxing</code> 也就是装箱，而它的逆过程就是拆箱。<strong>自动</strong>一词体现在 Java 会在适当的情况下自动拆装箱。<br>​在 Java 中万物皆对象的说法仅仅是适用于 OOP 思想层面上的，指的是现实中所存在的事物或抽象中的事物都可以当成对象，从而用程序的方式来实现对象的各种属性和特征，这个在我的另一篇将 OOP 的文章有详细讨论过**(我会填这个坑的)**。而在 Java 语法层面上这个说法显然是不合适的，因为基本数据类型就不是对象，static 关键字也有些“全局”的概念。因此基本数据类型即不是 Object 的一个子类，自然也就没有只有&quot;对象&quot;才特有的强大的功能特性。为了弥补这个缺陷，JDK 1.5 开始就实现了自动拆装箱，提高了编程效率。<!--这里最好能写一下什么时候会自动拆装箱，背后的原理/源码是具体怎么实现的--></p><h1 id="运算符">运算符</h1><p>  一般来说，运算符的用处最容易想到的就是根据自己的运算对象<strong>生成一个值</strong>。但除此之外，有些运算符还可以改变运算对象的值，这被称为<strong>副作用(Side Effect)</strong>。几乎所有的运算符都只能操作<strong>基本类型(Primitives)</strong> 的值，而 <code>=</code> , <code>==</code> , <code>!=</code> 三者却也能对象的运算。但其实严格来说 <code>+</code> 和 <code>+=</code> 也同样能参与对象的运算，因为字符串也是引用数据类型，这个我们会在后面讲到。并且和大多数语言一样，我们也可以利用 <code>()</code> 来调整运算优先级。<br>  请注意，<code>boolean</code> 类型的运算是受限的。你能为其赋值 <code>true</code> 或 <code>false</code>，也可测试它的值是否是 <code>true</code> 或<code>false</code>，但你就是不能对其作加减等其他运算。<br>  用 <code>=</code> 进行赋值运算时，右边是什么类型都可以，<!--可能并不是？？？-->而左边必须要是个<strong>明确的</strong>、已命名的变量，即要有一个<strong>物理的空间</strong>来存放右边的值。其中，基本数据类型的赋值都是<strong>直接的</strong>，而对象的赋值只是其<strong>内存的引用</strong>，这一点很重要。<br>  一元运算符有 <code>-</code> , <code>+</code> , <code>--</code> 和 <code>++</code>。<code>-</code> 可以得到数据的负值，而 <code>+</code> 唯一的作用就是将较小的数值类型自动转换为 int 类型。而 <code>--</code> 和 <code>++</code> 是除赋值运算符外，唯一具有<strong>副作用</strong>的运算符。每个都可以分为<strong>前后递增递减</strong>两个类型。具体来说，对于前递增和前递减 ( 如 <code>++a</code> 或 <code>--a</code> )，会先执行 <code>±1</code> 运算，再返回值。而对于后递增和后递减 ( 如 <code>a++</code> 或 <code>a--</code> )，会先返回值，再执行 <code>±1</code> 运算。<br>  在 Java 中，关系运算符包括 <code>&lt;</code>  , <code>&gt;</code> ,  <code>&lt;=</code> ,  <code>&gt;=</code> ,  <code>==</code> 和 <code>!=</code> 。其中，<code>==</code> , <code>!=</code> 可以用于所有类型，原因是关系运算符会通过产生一个布尔结果来表示操作数之间的关系。之后我们会在学习<strong>复用(Reuse)</strong> 时接触到<strong>覆写(Override)</strong>，到时我们会尝试覆写所有对象中都存在的 <code>equals()</code> 方法。<br>  在 Java 中逻辑运算符包括 <code>&amp;&amp;</code> (与)，<code>||</code> (或)，<code>!</code> (非)。与其它语言类似，Java 同样支持<strong>逻辑短路</strong>来节省部分不必要的运算，从而提高程序现在的性能。</p><h2 id="位运算符">位运算符</h2><p>  <code>&amp;</code> , <code>|</code> , <code>~</code> 分别是与或非三个位运算符，在这基础上加一个 <code>^</code> 异或运算符表示当两个输入位中，某一个是 1，而另一个是 0 时输出 1。<br>  我们将 Boolean 类型被视为<strong>单位值(one-bit value)</strong>，所以它多少有些独特的地方。我们可以对 boolean 型变量执行与、或、异或运算，但不能执行非运算（大概是为了避免与逻辑“非”混淆）。对于布尔值，位运算符具有与逻辑运算符相同的效果，只是它们不会中途“短路”。</p><h3 id="移位运算符">移位运算符</h3><p>  移位运算符面向的运算对象也是二进制的<strong>位</strong>。它们只能用于处理整数类型(基本类型的一种) 。左移位运算符 <code>&lt;&lt;</code> 能将其左边的运算对象向左移动右侧指定的位数 (在低位补 0) 。右移位运算符 <code>&gt;&gt;</code> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种<strong>不分正负</strong>的右移位运算符 <code>&gt;&gt;&gt;</code>，它使用了<strong>零扩展(zero extension)</strong> , 即无论正负，都在高位插入 0。<br>  如果移动 <code>char</code>、<code>byte</code> 或 <code>short</code>，则会在移动发生之前将其提升为 <code>int</code>，结果为int。仅使用<strong>右值(rvalue)</strong> 的 5 个低阶位。这可以防止我们移动超过 <code>int</code> 范围的位数。若对一个 <code>long</code> 值进行处理，最后得到的结果也是 <code>long</code> 。<br>  移位可以与等号 <code>&lt;&lt;=</code> 或 <code>&gt;&gt;=</code> 或 <code>&gt;&gt;&gt;=</code> 组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与byte 或short 一起使用的话，则结果错误。取而代之的是，它们被提升为 <code>int</code> 型并右移，但在重新赋值时被截断。在这种情况下，结果为 -1。<!--这三段你到底在说什么啊，清楚一点你可以吗--></p><h2 id="三元运算符">三元运算符</h2><p>  Java 提供了一种三元运算符可以简洁地替代 if-else 语句。其格式为：<code>[Boolean expression]? value1:value2</code> 。虽说是有三个输入位，但它确实也是操作符，因为它最终也会<strong>生成一个值</strong>。这个三元操作符意为若布尔表达式结果为 <code>true</code> ，则返回结果<strong>值 1</strong>，否则返回<strong>值 2</strong> 。其中，提供简便性的同时，也会使代码可读性降低，这就需要程序员设计时斟酌一下。</p><h2 id="常见陷阱">常见陷阱</h2><p>  接触过 C/C++ 的人都知道，非零值的布尔值为 <code>true</code>，而零值为 <code>false</code> 。但 Java 并没有这样的特性，并且也不支持整型强转布尔型，否则会发生编译错误。就是因为这样 Java 就避免了这样的一个错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x = y)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上程序是模拟了少打了一个等号的情况，我们知道，在 C/C++ 只要 <code>y</code> 值非零， 这个 <code>x = y</code> 布尔表达式的结果即为 <code>true</code> ，这显然在这样的一个在这样的循环里面是不符合逻辑的。而让 Java 来执行这个程序时，Java 会尝试将<strong>非布尔型强制转化成布尔型</strong>。但 <code>int</code> 转不了布尔型于是就发生了编译错误，避免了逻辑错误。当然，还有这种 <code>y</code> 是布尔型的情况可能出错，这个暂且不谈。但你如果想 <code>int</code> 强制转化为 <code>Boolean</code> 也不是没有办法，用一个三元运算符即可解决。</p><h1 id="控制流">控制流</h1><p>  这部分的内容的时候，最好有一点程序<strong>流程图(Flow Chart)</strong>，或者是 <strong>PAD图(problem analysis diagram)<strong>的知识，在学习一个语句时在脑海中建一个相关的简单的模型，可以加深理解和印象。<br>  下面介绍控制程序执行流程，简称</strong>控制流</strong>的一些要点。控制流中的执行语句我将会用 <code>statement</code> 来省略表示。这个执行语句既可以是 <code>;</code> 结尾的一条<strong>简单语句</strong>，也可以是包含在 <code>{}</code> 内的的<strong>复合语句</strong>，即封闭在大括号内的一组简单语句。</p><p><code>if</code> 和 <code>if-else</code> 语句几乎所有的编程语言都有就不做过多介绍了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression)<span class="comment">// if 语句</span></span><br><span class="line">    statement</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(Boolean-expresion)<span class="comment">// if-else 语句</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p><code>while</code> 的情况也差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Boolean-expression)</span><br><span class="line">    statement</span><br><span class="line"><span class="comment">// 执行语句会在每一次循环前，判断布尔表达式返回值是否为 true，直到返回 false.</span></span><br></pre></td></tr></table></figure><p>  <code>do-while</code> 和 <code>while</code> 唯一的区别是即使条件表达式返回结果为<code>false</code>，<code>statement</code> 也至少会执行一次。然而在实际应用中，<code>while</code> 比 <code>do-while</code> 使用次数更为频繁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(Boolean-expression);</span><br></pre></td></tr></table></figure><p>  <code>for 循环</code>可能是最常用的迭代形式。该循环在第一次迭代之前执行<strong>初始化</strong>。随后，它会执行布尔表达式，并在每次迭代<strong>正常结束</strong>时 (指没有被 return,break,continue 打断循环)，进行某种形式的<strong>步进</strong>。每次迭代之前都会判断布尔表达式的结果是否成立。一旦计算结果为 <code>false</code>，则跳出 <code>for 循环体</code>并继续执行后面代码，通常用于<strong>计数</strong>任务。值得一提的是，这个初始化的变量的作用域范围仅在 <code>for 循环体</code>内，并且初始化表达式、布尔表达式、不仅运算<strong>都可以为空</strong>。<br>  此外，Java 还提供了<strong>逗号运算符</strong>，这并不是之前一直用的分隔符。这种运算符只有一个用处：在 <code>for 循环</code> 的<strong>初始化</strong>和<strong>步进</strong>控制中<strong>定义多个变量</strong>，但要求定义的变量类型必须是相同的。值得一提的是，<code>for(;;)</code> 与 <code>while(true)</code> 的无异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; Boolean-expression; step)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>  <code>for-in</code> 语法也被称为<strong>增强版 for 循环</strong>，和 <code>Python</code> 中的 <code>for i in sequence:</code>  相似，同样是遍历**可迭代对象(iterable object)**中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type x: iterable-object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>  这条语句定义了一个 <code>type</code> 类型的变量 <code>x</code>，继而将 <code>iterable-object</code> 中每一个类型为 <code>type</code> 的元素赋值给它。Range 类中的 <code>range()</code> 方法可自动生成恰当的数组，经常与 <code>for-in</code> 循环搭配使用，只不过 Range 类需要手动静态导入。<br>  String 类有一个方法叫 <code>toCharArray()</code> 返回值类型为 <code>char</code> 数组。我们可以用 <code>for-in</code> 简单地遍历它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: <span class="string">"I was a loser."</span>.toCharArray());</span><br><span class="line">        System.out.println(c + <span class="string">" "</span>) <span class="comment">// I   w a s   a   l o s e r . </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="return">return</h2><p>  返回对象需要用到 <code>return</code> 关键字，执行到它时就意味着<strong>方法执行的结束</strong>，并且如果 return 后面有返回非 void 类型时返回该数据。当方法中只能返回 void 时，需要在创建方法的最开头补上 <code>void</code> 关键字表示该方法不需要返回值。当出现 <code>return; = return [void 类型]; = 返回空类型 = 没有返回值</code> 时，return 只有退出方法的作用，因此方法最后的 return 若返回 void，则可以被省略。</p><h2 id="标签">标签</h2><p>  对 Java 来说，<strong>唯一</strong>能用到标签的地方是要跳出多层循环的时候，类似于汇编语言中饱受争议的 <code>goto</code> 语句。<strong>标签</strong>由标识符和冒号构成，并且<strong>不允许</strong>在标签和循环之间置入如何语句，相当于标签和它所指示的循环是绑定在一起的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">label0:</span><br><span class="line">out-iteration &#123;</span><br><span class="line">    statement</span><br><span class="line">    label1:</span><br><span class="line">    inner-iteration &#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签是用于所有迭代语句，规则如下：</p><ol><li>简单的一个 <code>continue</code> 会退回到最内层循环的开头，并继续执行；</li><li>带有标签的 <code>continue</code> 会传送到标签的位置，并紧接着执行标签后面的循环；</li><li><code>break</code> 会退出当前循环；</li><li>带标签的 <code>break</code> 会中断当前循环，并传送到那么标签指示的循环的末尾。</li></ol><h2 id="switch">switch</h2><p>  不是老任的那个，<code>switch</code> 原意为”开关“或”转换器“。它是一种实现多路选择的干净利落的方式。一旦理解了switch，你会明白这其实就是一个逻辑扩展的语法糖。它提供了有异于繁琐的 <code>if-else</code> 新的编码方式，使得结果更清晰，提高代码可读性从而更易于理解和维护。我们不妨先来看一下它的结构再来一个一个解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integeral-selector) &#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value0 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3 : statement; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value4 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: statement;<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，每个 <code>statement</code> 后面的 <code>break</code> <strong>视你要执行的目的而定</strong>，甚至整个 switch 语句中一个 <code>break</code> 都没有也可以，<code>default</code> 的那个 <code>break</code> 是真的可有可无。<br>  <strong>整数选择因子(integral-selector)</strong> 实际上是个生成<strong>整数值(integral-value)<strong>的表达式，这个整数值必须是</strong>整型</strong>或是<strong>字符型</strong>。在执行到 <code>break</code> 之前 <code>switch</code> 将会用这个整数值从上到下和每个 <code>case</code> 的整数值相比较，如果是一样的那就执行这个 <code>case</code>，否则就不执行继续下一个。如果有的 <code>case</code> 都没有匹配成功，那就执行 default 后面的语句。可以看到 <code>switch</code> 真的就像是个开关一样，把开关”咔擦“拨到那里去程序向流水一样向指定的方向汇去。<br>  上面说过，整数值必须是整型或是字符型，那么对于其它类型，比如浮点型，则需要使用到枚举类型来搭配 switch 工作，从而避免使用一些列繁杂的 <code>if-else</code> 语句。针对于字符串型，Java 7 新增了字符串上的 switch 用法，无非就是把原来的整数值换成了字符串而已。</p><p>最后不妨设计一个小程序来探究 <code>Math.random()</code> 的取值范围来作为这篇文章的收尾吧。<br>  首先分析问题：Math 类库中的静态方法 random() 能生成 0~1 之间的 double 类的数值，问题是结果能不能取到 0 或者 1，因此我们需要分类讨论取 0 和取 1 的两种情况。那我们选择直接从命令行传递相关参数来直接调控两种情况。<br>  在以下代码中，<code>onjava</code> 是 onjava8 作者的一个包，而延时类 TimedAbort 则被封装在这个包中。这个类生成的对象能使程序在指定时间中结束，比如传入 3，就意味着程序运行后在三秒后结束。最后的 <code>exit(1)</code> 表示异常退出程序。此外还要考虑用户传入不合适的参数的情况并给予相应提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chiwei.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">// 传入相关参数</span></span><br><span class="line">        <span class="keyword">new</span> TimedAbort(<span class="number">3</span>);<span class="comment">// 程序将运行 3s 后退出</span></span><br><span class="line">        <span class="keyword">switch</span> (args.length == <span class="number">0</span> ? <span class="string">""</span> : args[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"lower"</span>:</span><br><span class="line">                <span class="keyword">while</span> (Math.random() != <span class="number">0.0</span>)</span><br><span class="line">                    ;   <span class="comment">// 保持重试</span></span><br><span class="line">                System.out.println(<span class="string">"Produced 0.0!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"upper"</span>:</span><br><span class="line">                <span class="keyword">while</span> (Math.random() != <span class="number">1.0</span>)</span><br><span class="line">                    ;   <span class="comment">// 保持重试</span></span><br><span class="line">                System.out.println(<span class="string">"Produced 1.0!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"Usage:"</span>);</span><br><span class="line">                System.out.println(<span class="string">"\tRandomBounds lower"</span>);</span><br><span class="line">                System.out.println(<span class="string">"\tRandomBoutds upper"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要运行程序只需在命令行或控制台中键入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java RandomBounds lower</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">java RandomBounds uppper</span><br></pre></td></tr></table></figure><p>  然而这种测试的效率是肉眼可见的效率低下，所以直接给出结论：<code>Math.random()</code> 方法的取值范围为 [0,1)，即能取到 0 而取不到 1。</p><h1 id="总结">总结</h1><p>  先把基础中的基础打牢，如果觉得还 Okay 的话，可以继续参考<strong>从一开始 Java 学习②</strong>，进而学习面向对象和函数式编程以及对象的初始化和清理，<strong>封装(implementation hiding)</strong> 的和核心概念。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入坑Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学计算机网络前瞻</title>
      <link href="/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/"/>
      <url>/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>初学计算机网路时整体的知识框架以及学习要求</strong></p><a id="more"></a><p><strong>读者定位</strong>：对没有接触过计算机网络但希望了解并学习的人群，给出了一个大致的 学习框架以及一系列基本要求。</p><p><strong>阅前须知</strong>：本文的所有内容都由程序🐏提供，更多内容请移步至羊哥的公众号(CodeSheep)，<a href="https://space.bilibili.com/384068749" target="_blank" rel="noopener">B站空间</a> 或 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">个人博客</a>。</p><blockquote><p>  计算机网络主要指的就是 TCP/IP 协议栈，TCP/IP已然称为互联网的基石，甚至可以被称作是互联网时代最伟大的发明。但学习 TCP/IP 技术栈被人饱受诟病的一点是 TCP/IP 大部分内容都封装在操作系统内核态，总是藏着掖着，老是见不得人，因此容易遗忘，学起来就比较痛苦。</p></blockquote><h2 id="一、TCP-IP协议体系的认知">一、TCP/IP协议体系的认知</h2><p>  TCP/IP 协议栈是一种分层的协议，自下而上依次包括 <strong>数据链路层</strong>、<strong>网络层</strong>(IP)、<strong>传输层</strong>(TCP,UDP)以及<strong>应用层</strong>(DNS,FTP,HTTPS,HTTP)。除了应用层是封装在<strong>用户空间</strong>中的，其余三层都是封装在<strong>操作系统内核空间</strong>中的，例如 Windows，Linux 操作系统内部当中。<br>  此外，用户最经常接触的就是应用层的协议，而被封装在操作系统内核空间的三层是不容易&quot;看&quot;到的。并且下一层对上一层是透明的，传输在每一层都是对等的。</p><h2 id="二、数据链路层">二、数据链路层</h2><p>需要掌握：</p><ol><li>以太网帧的格式</li><li>MTU 的概念</li><li>ARP/rARP 协议：地址解析/逆地址解析<ul><li>可以理解为链路层和网络层之间的中间协议</li><li>ARP 查询原理，ARP 的报文格式，ARP 缓存格式</li></ul></li></ol><h2 id="三、网络层">三、网络层</h2><p>需要掌握：</p><ol><li><p>IP 首部格式：如 16位分片标识、DF 不分片标志、MF 多分片标志、13位片偏移、8位生存时间TTL、16位的首部检查</p></li><li><p>IP 分片：</p><ul><li><p>给一个很长的数据包，它的总长度大于它的 MTU值时，必定要带来 IP 分片的问题，需要画出各个分片的情况。</p></li><li><p>如何避免 IP 分片：在应用层、传输层做限制</p></li><li><p>如何确定分片的顺序</p></li><li><p>接收端如何确定所有的 IP 分片全部到达</p></li></ul></li><li><p>IP 选路 — 路由表(route print)</p><ul><li>路由表中每个字段代表什么含义</li></ul></li><li><p>ICMP 协议</p><ul><li>可以理解为网络层和传输层之间的中间协议</li><li>ICMP 协议的报文格式</li><li>报文的两大分类，即 查询 + 报错</li><li>2种查询报文 + 5种差错报文</li></ul></li></ol><h2 id="四、传输层">四、传输层</h2><p>需要掌握：</p><ol><li>UDP 协议<ul><li>UDP 协议的特点 + 首部各个字段</li><li>伪包头</li></ul></li><li>TCP 协议<ul><li>TCP 协议的特点 + 首部字段 + 面向连接可靠机制</li><li>TCP 流量控制机制<ul><li>三次握手、四次挥手，同时打开、关闭、半关闭</li></ul></li><li>TCP 流量控制机制<ul><li>滑动窗口、慢启动、拥塞避免、快速重传、快速恢复</li></ul></li><li>TCP 超时重传机制<ul><li>定时器的应用</li></ul></li><li>伪包头</li></ul></li></ol><h2 id="五、应用层">五、应用层</h2><p>需要掌握</p><ol><li><p>DNS 协议</p><ul><li><p>域名到 IP 地址的 DNS 解析映射</p></li><li><p>名字空间</p></li><li><p>DNS 指针查询中的 反向查找 或 逆向解析 的基本原理</p></li><li><p>DNS 缓存</p></li></ul></li><li><p>FTP 协议</p><ul><li>网络界的活化石……</li><li>FTP 的两条连接，即 控制流 + 数据流</li><li>FTP 的两种工作模式，即 PASV + PORT</li><li>FTP 的各种指令 + 响应码</li><li>FTP 的断点续传 + 匿名 FTP</li></ul></li><li><p>HTTP 协议</p><ul><li>报文格式，即 请求报文 + 响应报文</li><li>报文头的各种字段</li><li>HTTP 各种字段码</li></ul></li><li><p>HTTPS 协议</p><ul><li>HTTPS 的详细握手过程</li><li>摘要算法、数字签名、数字证书的原理和过程</li></ul></li></ol><p>大佬的见解：</p><p><img src="/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/%E5%A4%A7%E4%BD%AC%E7%9A%84%E8%A7%81%E8%A7%A3.PNG" alt="大佬的见解"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑 Java 开发前瞻指南</title>
      <link href="/2020/01/27/%E5%85%A5%E5%9D%91%20Java%20%E5%BC%80%E5%8F%91%E5%89%8D%E7%9E%BB%E6%8C%87%E5%8D%97/"/>
      <url>/2020/01/27/%E5%85%A5%E5%9D%91%20Java%20%E5%BC%80%E5%8F%91%E5%89%8D%E7%9E%BB%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>给出了学习 Java 开发的一般路线</strong></p><a id="more"></a><p><strong>阅前须知</strong>：这是一个整理向的文章，仅供参考，实际效果因人而异。本文的大部分内容都由程序🐏提供，更多内容请移步至羊哥的公众号(CodeSheep)，<a href="https://space.bilibili.com/384068749" target="_blank" rel="noopener">B站空间</a> 或 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">个人博客</a>。其余书籍的一些推荐是作者实际阅读或练手后感觉还不错的。</p><blockquote><p>为什么选择 Java ？<br>Java 的生态圈<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>实在是太香了，各种各样的框架、开源项目，以及解决问题的方案很全。</p><p>书要看英文版的还是译版的？<br>初学一个技术的时候最好看中文版的，权威的书可以放心看中文版。如果要看英文版可以适当对照着译版看（出版社或网友翻译的都可以），没有译版可以拿他人用博客写的每章总结来代替。如果还是没有就只能摸爬滚打硬着头皮啃下去或者换一种媒介进行学习。不过我还是推荐书籍，线上线下老师讲课你都只能跟着老师的 pace 来学习，而书籍你可以随意翻页，学习自由度很高。</p></blockquote><h3 id="基础知识">基础知识</h3><ul><li>Java 编程语言的学习<ul><li>最好是配一些小练手的项目一起做</li></ul></li><li>基本<strong>数据结构及算法</strong><ul><li>非常的重要</li><li>OJ 网站<ul><li>LeetCode，PO，ZOJ，JUral , UVA</li></ul></li><li>竞赛题<ul><li>ICPC，PAT，CCF-CSP认证</li></ul></li></ul></li><li>关注代码质量</li><li>基本的网络知识：TCP/IP HTTP/HTTPS<ul><li>Java 开发做 Web应用的居多，现在的网站、APP、小程序都是一种 Web 模型。</li></ul></li><li>基本的设计模式<ul><li>模板、策略……</li></ul></li></ul><hr><h3 id="工具">工具</h3><ul><li>操作系统：Linux（因为很好的稳定性，实际的开发大多是在Linux上做的）<ul><li>CentOS,Ubuntu,Fedora</li></ul></li><li>代码管理：SVN / Git</li><li>持续集成（CI/CD）：Jekins</li><li>项目管理：<strong>Maven</strong> / Gradle<ul><li>有必要深入体系地学习</li></ul></li></ul><hr><h3 id="框架">框架</h3><p>框架意义就是应对复杂度，可以把很复杂的工作得到很好的精简。</p><h4 id="应用层框架">应用层框架</h4><ul><li><s>SSH (Structs +Spring + Hibernate)</s><ul><li>这个有点过时了</li></ul></li><li>SSM (Spring + Springmvc + Mybatis)<ul><li>Mybatis 数据库的访问层</li></ul></li><li>Spring Boot<ul><li>自动配置和自动装箱等等，使其成为最好上手的框架之一</li></ul></li></ul><h4 id="中间件">中间件</h4><ul><li>消息队列 (MQ/Message Queue)：RocketMQ文档,ActiveMQ文档<ul><li>解耦、异步处理……</li></ul></li><li>通信框架 &gt; 远程过程调用 (RPC/Remote Procedure Call)<ul><li>gRPC,thrift,dubbo,nettyspringCloud,微服务 等都和 PRC 有关</li></ul></li><li>ElasticSearch（数据库/搜索引擎）</li><li>……</li></ul><h4 id="数据库">数据库</h4><ul><li>SQL / Structured Query Language (结构化查询语言)<ul><li>MySQL / Postgre SQL</li></ul></li><li>NoSQL / Not only SQL（非结构数据库）<ul><li>Redis(高速缓存),Memcahed(缓存),mongodb(文档SQL),ElasticSearch</li></ul></li></ul><h2 id="架构">架构</h2><h4 id="分布式-微服务架构">分布式/微服务架构</h4><p>​传统开发一般是个单体开发，一味地向一个项目堆积各种功能。微服务的出现使得将功能进行拆分，形成很多个微型单元模块，之间再通过 PRC 或 HTTP 相互进行调用。</p><ul><li>Spring Cloud</li><li>dubbo</li><li>RPC 通信框架</li></ul><h4 id="虚拟化-容器化技术">虚拟化/容器化技术</h4><ul><li>Docker 容器<ul><li>类似黑盒，将内部复杂的功能屏蔽掉，<strong>应对复杂度</strong>。</li></ul></li><li>容器集群（K8S/kubernetes）<ul><li>管理容器的工具</li></ul></li></ul><h2 id="源码-性能">源码/性能</h2><p>需要有丰富的编程经验、运维经验等等，难度较高。</p><ul><li>JDK 源码以及部分设计思想</li><li>Spring 源码</li><li>JVM 细节和排错<ul><li>永恒的话题</li></ul></li><li><strong>高并发/高可用</strong></li></ul><h2 id="技术学习方法">技术学习方法</h2><p>以学习 Spring Boot 技术为例</p><h4 id="认知、了解">认知、了解</h4><p>​这一阶段主要是掌握这个技术的相关概念和应用方向，并且由于人总有一种先入为主的观点，因此对某个技术点的第一印象非常重要，防止跑偏。</p><ul><li>了解 Spring Boot 的百科定义</li><li>Spring Boot 解决了什么问题<ul><li>Spring Boot 就是一个典型的 Web后端框架，驱动一个网站的后端，相应前端发送过来的数据。</li></ul></li><li>知道同类技术具体有哪些<ul><li>Spring Boot(Java),beego(Go),flask(Python),diango(Python),thinkphp(PHP)</li></ul></li><li>了解技术的主要组成部分<ul><li>Spring 框架的 IOC容器、AOP切面</li></ul></li><li>思考该技术为什么会出现</li></ul><h4 id="学语法、学用法">学语法、学用法</h4><p>这个过程中要 多思考、多提炼、多总结、多写博客</p><ul><li>一般视频教程<ul><li>效率较低</li></ul></li><li>快速demo搭建视频 / 快速上手视频</li><li>阅读入门级的博客</li><li>阅读权威性的书籍</li><li>阅读官方文档</li></ul><h4 id="局部练习、小型实战、搭环境">局部练习、小型实战、搭环境</h4><p>踩坑及时记录、多思考、多提炼、多提炼、谢谢博客</p><ul><li>相关语法知识点的代码练习</li><li>实战小demo</li><li>搭建环境</li></ul><h4 id="上手实际项目、开源项目">上手实际项目、开源项目</h4><p>要求网络数据结构、网络、环境、语法等基础非常牢固</p><ul><li>了解项目内容</li><li>把项目在 IDE 里跑起来</li><li>调这个开源项目</li><li>结合一些脑图、流程图、UML 类图 阅读项目代码</li><li>自定义开源项目</li></ul><h4 id="造轮子、源码阅读、Github-开源项目">造轮子、源码阅读、Github 开源项目</h4><p>最高境界……</p><h2 id="理论课程选择">理论课程选择</h2><h4 id="计算机基础理论课">计算机基础理论课</h4><p>直接决定自身的一个计算机的素养，以及学习并理解新技术的深度。</p><ul><li>《计算机导论》</li><li>《计算机体系结构》</li><li>《计算机系统结构》</li><li>《计算机组成原理》</li><li>《微型计算机技术》</li></ul><h4 id="软件工程基础理论课">软件工程基础理论课</h4><ul><li>《软件工程》</li><li>《软件架构》</li></ul><h4 id="操作系统">操作系统</h4><ul><li>《操作系统》</li></ul><h4 id="数据结构">数据结构</h4><ul><li>《数据结构》</li></ul><h4 id="计算机网络">计算机网络</h4><ul><li>《计算机网络》</li></ul><h4 id="程序设计语言">程序设计语言</h4><ul><li>《Java 程序设计语言》</li><li>《C 程序语言设计》</li></ul><h4 id="数据库-v2">数据库</h4><ul><li>《数据库》</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>编程的目的是产生实用的<strong>程序和软件</strong>，仅仅语言本身是很难实现这个目的的。<strong>语言</strong>之外，还要有<strong>编译器</strong>、<strong>集成开发环境（IDE）</strong>、 <strong>第三方功能模块</strong>、<strong>帮助文档</strong>等等，此外还要有<strong>技术社区</strong>供编程者交流和学习。这些东西合起来，就是一个==生态环境==。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入坑Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
