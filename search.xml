<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初见数据结构与算法</title>
      <link href="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要</strong>：为初学者快速上手数据结构与算法。</p><a id="more"></a><p><strong>阅前须知</strong>：本文仅提供学习数据结构与算法的一个初步的知识框架，仅供参考，实际效果因人而异。该文章所参考的书籍绝大部分来自《算法图解》，少部分来自《算法导论》。</p><blockquote><p>​我承认，精准且严谨的定义固然是重要的，因为所有与之相关的理解都要建立在这个定义的基础上。但有时有些晦涩的定义直接上手可能会非常地棘手，因此可以先从定义的相关的应用或实例入手，通过<strong>合理恰当的打比方</strong>的方式，先对定义产生初步的了解，再通过练习不断地修正，力图接近真实的定义，最终可以达到所谓事半功倍的效果。<br>​因此，我想表达的是，文章可能会出现几处严谨性欠佳的描述，我会在那后面力争把它“圆”回来，并附上一个或者多个认可度较高的定义及出处。</p></blockquote><h2 id="何为算法">何为算法</h2><p>​《算法导论》对算法的定义为：非形式地说，算法就是任何良性定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样的算法就是把输入转换成输出的计算步骤的一个序列。<br>​讲真，上面这段定义看不看懂不重要，目前可以姑且认为算法就是函数三要素中的<strong>对应法则 f</strong> 即可，我们只需知道算法的重要性以及应用就够了。<br>​算法可谓是现代信息技术的灵魂，它指挥着各种各样可处理的数据。一个<strong>优秀</strong>的算法要求在<strong>尽可能短的时间和空间</strong>内结束并返回<strong>正确的结果</strong>。于是，评判一个算法优劣的指标——<strong>时间复杂度</strong>和<strong>空间复杂度</strong>，应运而生。其中，时间复杂度常常用<strong>大 O 表示法</strong>进行合理地量化并表示。</p><p><strong>大 O 表示法</strong>：表示为完成指定任务，某个算法在最坏的情况下所执行的操作数，其中 n 为总元素个数，可以指出该算法有多快，即操作数随元素总量的增速。常见的大 O 运行时间有 O(log n),O(n * log n),O(n),O(n<sup>2</sup>),O(n!),算法速度依次递减。但在实际情况下除最早情况下的运行时间外，还应考虑平均情况的运行时间。值得一提的是，大 O 表示法通常不考虑加减乘除的数字。O(1) 被称为常量时间，意味着不管有多少个元素，所需要的时间都相同。</p><p><strong>二分查找</strong>：需要先对数组进行排列，后执行。算法运行时间为 O(log n)。</p><p>前面提到的《算法导论》中，有句话特别在理：<strong>Having a solid base of algorithm knowledge and technique is one characteristic that separates the truly skilled programmers from the novices.</strong><br>意为，是否具有扎实的算法知识和技术基础，是区分真正熟练的程序员与新手的一项重要特征。</p><h2 id="第二章-选择排序">第二章 选择排序</h2><p><strong>选择排序</strong>：新建一个空数组1，把待排序数组2中最小（大）的找出来放进数组1中，重复前一个步骤，直到数组2全空。</p><p>​你需要将<strong>内存空间</strong>想象成宾馆储物抽屉柜，每个抽屉只能储存一个物品。你可以选两种储存方式，连续的抽屉进行储存，或离散地进行储存，但上一个抽屉储存着下一个抽屉的地址。前者的管理方式好处和坏处都很明显，好处是你只需要记住第一个物品的位置，就可以瞬间知道第几个物品的位置在哪里。但坏处是当你抽屉组的最前端和最后段都有物品时，如若需要增加物品，你只能把所有元素全部搬到更大的连续的抽屉组中，非常费力，当然你也可以提前申请足够大的空间，但如若实际最后用不上那么多，那也是对空间的极度浪费。后者就没有这样的困惑，想放哪里就放哪里。但如若想知道第 n 个抽屉位置，就需要 n-1 个抽屉的位置，以此类推，全部遍历，效率比较低下。<br>​前者的数据结构叫<strong>数组</strong>，而后者叫做<strong>链表</strong>。如若经常需要从头遍历所有元素，用链表会更好一些，但需要随机读取元素，则一般需要数组来帮忙。或者更一般地来说，如果数据被创建下来之后不会再修改其长度，则用数组，否则用链表。</p><p>​数组和链表还被用来实现其他数据结构，比如 Facebook 实际使用的是什么呢？很可能是十多个数据库，他们居于众多不同数据结构：散列表、B数等。数组和链表使这些更复杂的数据结构的基石。</p><h2 id="第三章-递归">第三章 递归</h2><p>​<strong>伪代码</strong>是对手头问题的简要描述，看着像代码，但其实更接近自然语言。<br>​对于一个函数来说，全局变量引用是没有问题的，当函数内部命名了与全局变量一样的标识符时，这个变量就和全局变量没关系了，除非你提前声明这是全局变量。</p><p>​每个递归函数都有两部分：<strong>基线条件（base case）和递归条件（recursivecase）</strong>。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br>​凡是数据结构都由自己的操作，比如数组和链表就有读取、插入、删除、修改等操作。而对于<strong>栈</strong>来说，它的操作只有压入[<sup>插入]和弹出[</sup>删除并读取]。<br>​当一个栈用于存储多个函数的变量时，被称为<strong>调用栈</strong>。因为每当你调用函数时，计算机都将函数调用所涉及的变量的值存储到内存中。当一个函数调用返回时，就从栈的顶部弹出。<br>​使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择。一种是将递归化为循环解决，另一种是<u>尾递归</u>，这就是另一个故事了。[^高级话题]</p><h2 id="第四章-快速排序">第四章 快速排序</h2><p>​有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的 算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。<strong>分而治之</strong>（divide and conquer，D&amp;C）是你学习的第一种通用的问题解决方法。快速排序就是使用分而治之策略的一种优雅的排序算法。<br>​D&amp;C 思路是递归的，使用 D&amp;C 解决问题的过程包括两个步骤：</p><ol><li>找出简单的基线条件。</li><li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li></ol><p>​==编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，有必要检查一下基线条件是不是这样的。</p><p>**函数式编程：**诸如 <strong>Haskell</strong> 等函数式编程语言没有循环，因此你只能使用递归来编写类循环。例如，函数 sum 可以这样编写。</p><pre><code>sum[] = 0sum(x:xs) = x + (sum xs)# 用函数式程序设计语言 Haskell 所编写的 sum 函数。sum arr = if  arr == []            then 0            else (head arr) + (sum (tail arr))# 用循环编写 sum 函数。</code></pre><p>**归纳证明：**归纳证明是一种证明算法行之有效的证明方式。它分为基线条件和归纳条件，在数学领域中被称为第一类数学归纳法。归纳证明常常与 D&amp;C 协同发挥作用。</p><p>**快速排序：**C语言标准库中的 <strong>qsort</strong> 函数实现的就是快速排序，是一种比选择排序快得多的排序算法，快排的平均大 O 运行时间为 O(n*log n )。其基本步骤为：</p><ol><li><p>数组的 pivot[^基准值]的选取。</p></li><li><p>分别创建两个数组，其中包含除 pivot 外小于等于 pivot 的，以及大于 pivot 的。</p></li><li><p>分别对这两个数组进行快排。</p></li></ol><p>​快速排序的实际运行时间很大程度上都由 pivot 决定，如果 pivot 一直选取数组第一个元素时，它的栈的高度就为 n，每层的操作数也为 n==[这里不太懂]==，最终的运行时间为 O(n<sup>2</sup>)。而如果每次都选取中间的元素时，栈的高度就是 log n，每层的操作数还是 n==[同上]==。</p><p>**深入了解大 O 表示法：**我们说 大 O 表示法中常量是忽略的。这里的常量一般指的是每进行一次操作时所需要的时间，用 <strong>c</strong> 表示。因此大致准确的运行时间应该是 c * O([^关于 n 的表达式])。当处理的数据非常大时，c 对结果的影响相较于 O() 就非常小了，因此经常把 c 忽略掉。但当两种算法的 O() 相等时，就要考虑 c 的大小来判断算法的优劣了。合并排序的运行时间一直为 O(n*log n)，而快排的平均运行时间也为 O(n*log n)，但最糟情况下，其运行时间为 O(n<sup>2</sup>)，但事实上，人们更偏爱于快排，究其原因就因为快排的 c 比合并排序小。</p><h2 id="散列表">散列表</h2><blockquote><p>散列表可以说是最有用的基本数据结构之一了。它的内部机制有：实现、冲突和散列函数。</p></blockquote><p><strong>散列函数</strong>：随便给你一个能处理的数据，通过散列函数的映射，必定将这个数据映射为一个数字，而<strong>理想的散列函数</strong>能够保证所有不同的数据映射出的数字相互不同。</p><p>**散列表：**散列表结构上由散列函数与数组构成，内容上由键值对构成。与一般数组和链表不同的是，它们都被直接映射到内存，但散列表包含额外逻辑，即使用散列函数来确定元素的储存位置。这样的散列表又被称为是散列映射、映射、字典和关联数组。</p><p><strong>关于散列表的应用：</strong></p><ul><li>将散列表用于查找<ul><li>储存电话号码和联系人似乎用散列表是比较好的，这是个简单例子。不妨稍微谈一下高级话题，比如 DNS 解析[^DNS resolution]。访问像 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 这样的网站时，计算机要先将域名转换为 IP 地址,即 74.125.239.133，无论是什么网站都得这么做，转换的过程其实就是将网址映射到 IP 地址上去，这时散列表就有它的用武之地了。</li></ul></li><li>防止重复<ul><li>检查名单中是否这个人已经签到过了，没有签到过就签到上，用字典中的 get 函数。</li></ul></li><li>将散列表用作缓存<ul><li>​缓存是一种常用的加速方式，所有的大型网站都使用缓存，而缓存的数据则储存再散列表中。当你访问 Facebook 的网页时，它会先接入他们的服务器，如果这个网页是所有用户看到的都是一样的，那就会将事先保存好的网页展示给你，不然服务器就对网页做些处理，将生成的网页展示给你。这就是缓存，它具有两个优点，用户能更快地看到网页，Facebook 需要做的计算量更少。<br>​总而言之，就是当 URL 不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次游刃请求该 URL 时，你就可以直接发送缓存中的数据，而不用在进行处理了。</li></ul></li></ul><p>**冲突：**由于大多数语言都提供了散列表实现，因此你不用发明轮子，但你以然需要考虑性能，这其中冲突就是关键。当同一个值需要对应多个键时，就产生了冲突。解决这种冲突的方法就是，当多个键映射到了同一个位置，就在这个位置存储一个链表，但一旦这个链表的元素一多，散列表的速度将急剧下降，以至于在最糟情况时，散列表的各种操作的运行时间都是 O(n)。==然而，如果使用的散列函数很好，这些链表就不会很长。==想要尽可能地避免冲突，需要有较低的装填引子和良好的散列函数，当然这就是另一个故事了。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">散列表(平均情况)</th><th style="text-align:center">散列表(最糟情况)</th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">读取</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr></tbody></table><h2 id="广度优先搜索">广度优先搜索</h2><blockquote><p>根据作者所知道的算法中，图算法应该是最有用的，而广度优先搜索就是图算法的一种，它能够找出两样东西之间的最短距离。</p></blockquote><p>**最短路径问题：**像从旧金山双子峰到金门大桥的最少换成次数，或者去你朋友家的最短路径，再或者是国际象棋中把对方将杀死的最少步数。都被称为是最短路径问题。</p><p>​要解决最短路径问题通常需要两个步骤：</p><ol><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ol><p><strong>何为图？</strong><br><strong>图用于模拟不同的东西是如何相连的</strong>，它由<strong>节点</strong>和<strong>边</strong>组成，一个节点所<strong>直接指出去</strong>的所有节点统一称作是<strong>邻居</strong>。</p><p><strong>何为广度优先搜索？</strong><br>广度优先搜索是一种用于<strong>图</strong>的<strong>查找算法</strong>，它可以解决两类问题：</p><ol><li><p>从节点 A 出发，有通往节点 B 的路径吗？</p></li><li><p>如果有，那么从节点 A 出发，通往节点 B 的哪条路径最短？</p></li></ol><p>​以节点 A 为中心，节点 A 的邻居被称为是节点 A 的<strong>一度关系</strong>，邻居的邻居被称为是<strong>二度关系，以此类推</strong>。在广度优先搜索看来，<strong>一度关系胜过二度关系，二度胜过三度</strong>，因此它会先在一度关系中查找有没有节点 B，一度没有就找二度，二度没有就去三度，<strong>直到找到为止或者所有的节点都遍历过一遍为止</strong>。</p><p><strong>队列：<strong>队列的工作原理与现实生活中的队列完全相同，是一种数据结构。它只支持两种操作，即</strong>入队</strong>和<strong>出队</strong>。Python 中可以从 cllections 库中引入 deque 函数来创建一个双端队列。</p><p>​为了实现广度优先搜索算法，我们需要先实现图，再去通过队列的先进先出的特性来实现算法。</p><p><strong>实现图：<strong>首先要承认尽管图结构是一样的，但由</strong>中心节点的选取</strong>的不同所呈现出的图是不一样的。没有邻居的节点被称为是<strong>有向图</strong>，互为邻居的节点被称为是<strong>无向图</strong>。像这样一个节点对应多个节点的结构像极了映射，因此我们可以用<strong>散列表</strong>来储存图，Python 实现图就用字典，key 是单个节点，value 是数组。</p><p>**实现算法：**先用队列按照几度关系的顺序依次将节点入队。具体步骤为：</p><ol><li>创建一个搜索队列</li><li>将中心节点的邻居添加至队列中</li><li>只要搜索队列不是空的，建立循环<ol><li>将一个节点 popleft() 赋值给变量 P</li><li>检查 P 有没有被检查过<ol><li>检查 P 是不是<strong>目标节点</strong><ol><li>如果是则返回 True</li><li>如果不是则将 P 的邻居添加到队列中</li></ol></li></ol></li></ol></li><li>返回 False</li></ol><p>​在最糟糕的情况下，你需要遍历整个图，也就是说每条<strong>边</strong>都要走一次，并且你需要对每个节点进行依次检查，于是<strong>大 O 运行时间为 O(V + E)</strong>，其中 V][^vertice] 为节点数，E[^edge] 为边数。</p><p>**拓扑排序：**某种列表是有序的，</p><h2 id="狄克斯特拉算法">狄克斯特拉算法</h2><p>​我们说广度优先搜索是解决<strong>最短路径</strong>问题，那么狄克斯特拉算法就是解决<strong>最快路径</strong>问题。值得一提的是狄克斯特拉算法只适用于<strong>有向无环图</strong>以及<strong>非负权边</strong>的情况。</p><p>狄克斯特拉算法包含以下几个步骤。</p><ol><li>设中心节点为 A，列出如下表格。</li></ol><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">父节点</th><th style="text-align:center">耗时</th></tr></thead><tbody><tr><td style="text-align:center">A 的邻居 B</td><td style="text-align:center">A</td><td style="text-align:center">α</td></tr><tr><td style="text-align:center">A 的邻居 C</td><td style="text-align:center">A</td><td style="text-align:center">β</td></tr><tr><td style="text-align:center">非 A 的邻居 D</td><td style="text-align:center">其它</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">目标节点</td><td style="text-align:center">其它</td><td style="text-align:center">∞</td></tr></tbody></table><ol start="2"><li>循环开始：<ol><li>找出所有节点中**“耗时”最少**的节点，在这里不妨设 α &lt; β，因此我们很轻松地找出了节点 B。</li><li>计算 A 到 B 每个邻居的“耗时”，若 结果 小于 原有结果，则<strong>更新相应节点的“耗时”与“父节点”的值。</strong></li><li>由于 B 的邻居都已更新完毕，因此 节点 B <strong>不再参与</strong>下一轮的循环。<strong>直到所有节点的邻居更新完毕。</strong></li></ol></li><li>根据目标节点的父节点，向前依次<strong>追踪节点</strong>，直到某个节点的父节点为 中心节点 A，得出完整最短路线。</li></ol><p><strong>权重</strong>：应用狄克斯特拉算法时，图中每条边都有与之相关联的<strong>数字</strong>。并且，带权重的图被称为是<strong>加权图</strong>，不带权重的图被称为时<strong>非加权图</strong>。</p><p>Q：为什么算法实现的充分条件是<strong>有向无环图</strong>？</p><p>A：若节点与节点之间相互成“环”，那么每循环“环”一次总耗时就要无意义地增加，这样的路径不可能是<strong>最快路径</strong>。</p><p>Q：为什么算法实现的充分条件是<strong>不存在负权边</strong>？</p><p>A：若含有负权边，那么在后续的循环中，有可能会更新之前已经淘汰掉的节点的“耗时”以及“父节点”的值，如上述的 节点 B，这时理应要再对 节点 B 进行一次检查，可是由于 节点 B 已经淘汰掉了，因此无法更新 B 的邻居们。所以可能会使<strong>真实结果</strong>和<strong>实际演算结果</strong>产生不小的出入（其实就是贪心的锅，导致只能求解近似解），狄克斯特拉算法看起来就像是出了 bug 一样。因此，应对这种情况，我们必须换一个算法来实现——<strong>贝尔曼-福德 算法</strong>，当然这就是另一个故事了。</p><h3 id="关于实现">关于实现</h3><p>以表格作为出发点，需要用到三个散列表来装填三种数据，即 graph , parents , costs，而其中 graph 还需要存储各个边的权重，因此需要再套一层散列表，即 第一层 = 键:值 = <strong>节点:第二层散列表</strong>，第二层 = 键:值 = <strong>邻居:边的权重</strong>。</p><h2 id="贪心算法">贪心算法</h2><p><strong>贪心算法</strong>：又称贪婪算法，即 每步都选择的<strong>局部最优解</strong>，最后得到<strong>近似</strong>全局最优解或<strong>全局最优解</strong>，采取的是一种步步为“赢”的策略手段。</p><p><strong>NP完全问题</strong>：你需要计算所有的解，并从中选出 最小/最短 的那个，从而求得精确最优解。而往往这种暴力算法所带来的运行速度都是非常糟糕的，这时采用贪心算法，虽然为近似解，但通常可以将运行速度控制在 O(n<sup>2</sup>) 以内。</p><h3 id="NP完全问题模型—集合覆盖问题">NP完全问题模型—集合覆盖问题</h3><p>​假设你办了个广播节目，要让全美 50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。广播台的名单 demo 如下。</p><table><thead><tr><th style="text-align:center">广播台</th><th style="text-align:center">覆盖的周</th></tr></thead><tbody><tr><td style="text-align:center">KONWE</td><td style="text-align:center">ID,NV,UT</td></tr><tr><td style="text-align:center">KTWO</td><td style="text-align:center">WA,ID,MT</td></tr><tr><td style="text-align:center">KTHREE</td><td style="text-align:center">OR,NV,CA</td></tr><tr><td style="text-align:center">KFOUR</td><td style="text-align:center">NV,UT</td></tr><tr><td style="text-align:center">KFIVE</td><td style="text-align:center">CA,AZ</td></tr></tbody></table><p>​每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。而我们呢现在的问题是如何找出覆盖全美 50个州的最小广播台集合，这听起来很容易，但其实运算量极大，具体方法余下。</p><ol><li>列出每个可能的广播台集合，这被称为 幂集（power set）。因此，可能的子集有 2<sup>n</sup>个（包括空集）。</li><li>在这些 2<sup>n</sup>个子集中，选中覆盖全美 50个州的最小集合。</li></ol><p>​当然，n 在 0~10 的区间范围内还好说，但当 n 超过了这个范围，实际操作数将急剧增加，更为痛苦的是，目前<strong>没有任何算法</strong>可以足够快地解决这个问题。这时就需要**近似算法（approximation algorithm）**解决类似的问题，具体方法如下。</p><ol><li>选出这样一个广播台，即 它覆盖了最多的未覆盖州。即便这个广播台也同时覆盖了一些已覆盖的州，也没有关系。</li><li>重复第一步，直到覆盖了所有的州。</li></ol><p>具体的 Python 代码如下。</p><pre><code>states_needed = set([&quot;mt&quot;, &quot;wa&quot;, &quot;or&quot;, &quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;, &quot;ca&quot;,&quot;az&quot;])  # 传入一个数组，并转换为集合。arr = set([1, 2, 2, 3, 3, 3])stations = {}  # 需要有可供选择的广播台清单，使用散列表来表示它。stations[&quot;kone&quot;] = set([&quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;])stations[&quot;ktwo&quot;] = set([&quot;wa&quot;, &quot;id&quot;, &quot;mt&quot;])stations[&quot;kthree&quot;] = set([&quot;or&quot;, &quot;nv&quot;, &quot;ca&quot;])stations[&quot;kfour&quot;] = set([&quot;nv&quot;, &quot;ut&quot;])stations[&quot;kfive&quot;] = set([&quot;ca&quot;, &quot;az&quot;])final_stations = set()  # 需要一个集合来储存最终选择的广播台。while states_needed:  # 不断地循环，直到states_needed为空。    best_station = None     # 准备遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台存储在 best_station 中。    states_covered = set()    for station, states in stations.items():  # for循环迭代每个广播台，并确定它是否是最佳的广播台。        covered = states_needed &amp; states  # covered 包含当前广播台覆盖的一系列还未覆盖的州        if len(covered) &gt; len(states_covered):  # 检查该广播台覆盖的州是否比 best_station 多。            best_station = station            states_covered = covered  # states_covered 包含该广播台覆盖的所有未覆盖的州。            states_needed -= states_covered  # 更新 states_needed。            final_stations.add(best_station)print(final_stations)  # 输出结果为 set(['ktwo', 'kthree', 'kone', 'kfive'])</code></pre><h3 id="NP完全问题模型—旅行商问题">NP完全问题模型—旅行商问题</h3><p>​有一位旅行商，他需要前往 n个城市，同时保证旅程最短。因此他需要考虑各种各样可能的顺序情况，而对于每种顺序，他都要计算总旅程，再挑选出旅程最短的路线，那么很明显，他需要考虑 n! 个顺序情况。<br>​针对这种问题，当 n 比较大时，可以采取贪婪算法，具体步骤为。</p><ol><li>选定一个起点城市。</li><li>去往离起点城市最近的城市，并将起点城市更新为该城市。</li><li>重复上述步骤。</li></ol><h3 id="如何识别NP完全问题">如何识别NP完全问题</h3><p>​旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。<br>​通常来说，用 贪婪算法 解决一个 NP完全问题并不难，而真正难的部分则是意识到这是个 NP完全问题。下面列出几个判断 NP完全问题的经验性规律。</p><p>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</p><ul><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ul><h2 id="动态规划">动态规划</h2><blockquote><p>动态规划相较于其它算法来说，是属于比较重要，但同时也比较麻烦的一种算法。因此这里先了解一个例子再根据这个例子具体说明可能会好理解一点。</p></blockquote><h3 id="背包问题">背包问题</h3><h4 id="描述">描述</h4><p>​假设你现在是一个不折不扣的小偷，晚上进商城准备偷东西，你的背包很神奇，它装东西本领只和这个东西的重量有关，不妨限定你的背包最多只能装 4kg的东西。下面是你想偷的东西的清单，每件商品只有一个。</p><table><thead><tr><th style="text-align:center">商品</th><th style="text-align:center">音响(S)</th><th style="text-align:center">笔记本电脑(L)</th><th style="text-align:center">吉他(G)</th><th style="text-align:center">IPhone(I)</th></tr></thead><tbody><tr><td style="text-align:center">价格</td><td style="text-align:center">￥3000</td><td style="text-align:center">￥2000</td><td style="text-align:center">￥1500</td><td style="text-align:center">￥2000</td></tr><tr><td style="text-align:center">重量</td><td style="text-align:center">4kg</td><td style="text-align:center">3kg</td><td style="text-align:center">1kg</td><td style="text-align:center">1kg</td></tr></tbody></table><p>​你的目标很明确，在有限的容量里装入尽可能多的有价值的物品。因为你明白这其中要满足某种配比才有可能是问题的最优解（比如，拿走一个 笔记本电脑 和一个 IPhone 才可能是最赚的），但你不确定。因此，你掏出纸和笔打算写一个动态规划网格。我承认这可能很突然，但先照着做一下。</p><table><thead><tr><th style="text-align:center">商品/容量</th><th style="text-align:center">1kg</th><th style="text-align:center">2kg</th><th style="text-align:center">3kg</th><th style="text-align:center">4kg</th></tr></thead><tbody><tr><td style="text-align:center">吉他</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">音响</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">笔记本电脑</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">IPhone</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>​其中，网格的各行为商品，各列为不同容量（1~4kg）的背包。首先要声明的是，待会儿要填满这里所有的单元格，因为它们将帮助你计算背包的最大价值。<strong>你要做的事情是</strong>：逐行填写，填完一行再填下一行。填 a 行 b 列时，你假定现在只能偷 <strong>小于等于 a 行</strong> 的商品，且你的背包大小只有 <strong>b kg</strong>。举个例子，当你填 <strong>第二行 第三列</strong> 的单元格时，你只能偷 <strong>吉他</strong> 以及 <strong>音响</strong>，并且你的背包容量只有 <strong>3kg</strong>，这时将所能带走的最大价值填入所对应的单元格中。</p><h4 id="揭晓">揭晓</h4><p>​看完上面有点懵是正常的，觉得意义不明也有可能，因此需要适当“放”出来一点东西出来缓和以下。<br>​动态规划讲究将原问题划分为 n 个子问题，所以我们才将背包容量这个<strong>限制条件</strong>划分成 4 大块。通过解决第 1 个子问题，<strong>保存</strong>结果，接着解决第 2 个子问题时可以<strong>调用</strong>之前的结果，类似于尾递归。因此填表的时候沿着一列往下走时，最大价值不可能降低。因为每次迭代时，你都存储了当前的最大价值，最大价值不可能比之前还要低。<br>​值得一提的是，这 n 个子问题之间必须是相互独立且<strong>离散</strong>的。拿背包问题举例，如果拿了笔记本电脑之后再拿 IPhone 时电脑会爆炸，简言之就是电脑的价值会受手机的影响，这样的情况是用不了动态规划的。<br>​设行数为 i，列数为 j，cell 表示表格， α 为当前物品的价值，β 为当前物品的所占空间，则：<strong>cell[i][j] = max{cell[i-1][j] , α + cell[i-1][j-β]}</strong>， 即<br><strong>每个单元格的价值 = 上一个单元格的价值 与 当前商品的价值 + 剩余空间的价值 的两者的较大值</strong>。<br>​按照上述公式所填写的完整的表格如下，其中最大价值为￥4000，也就是说当你的容量只有 4kg 的背包，装一个 IPhone 和一个笔记本电脑时，收益才能达到最大化。</p><table><thead><tr><th style="text-align:center">商品/容量</th><th style="text-align:center">1kg</th><th style="text-align:center">2kg</th><th style="text-align:center">3kg</th><th style="text-align:center">4kg</th></tr></thead><tbody><tr><td style="text-align:center">吉他(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td></tr><tr><td style="text-align:center">音响(S)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥3000</td></tr><tr><td style="text-align:center">笔记本电脑(L)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥1500(G)</td><td style="text-align:center">￥2000(L)</td><td style="text-align:center">￥3500(LG)</td></tr><tr><td style="text-align:center">IPhone(I)</td><td style="text-align:center">￥3500(I)</td><td style="text-align:center">￥3500(IG)</td><td style="text-align:center">￥3500(IG)</td><td style="text-align:center">￥4000(IL)</td></tr></tbody></table><p>​在背包问题中，随意调换某两行都不会影响最终结果，甚至逐列填写单元格也没关系，但在其它动态规划模型中就不一定成立了。你也可以在最后一行添加一个任意一个商品而不影响上面的计算结果，当然前提是这件商品的重量是个整数，如果不是整数则要重新划分价格区间。</p><h3 id="动态规划问题">动态规划问题</h3><ol><li>需要在给定<strong>约束条件</strong>下<strong>优化某种指标</strong>时。例如在背包问题中，你必须在背包容量给定的情况下，拿到价值最高的商品。</li><li>问题可分解为<strong>离散</strong>的子问题时。</li></ol><h3 id="动态规划的认知">动态规划的认知</h3><ol><li><strong>每种动态规划解决方案都涉及网络</strong>。</li><li><strong>单元格中的值</strong>通常就是你要<strong>优化的值</strong>。在背包问题中，单元格的值为商品的价值。</li><li>每个单元格都是一个子问题，因此你该考虑如何将问题分成子问题，这有助于你找出网格坐标轴。</li><li>没有放之四海而皆准的计算动态规划解决方案的公式。</li></ol><h3 id="动态规划问题建模">动态规划问题建模</h3><p>遇到动态规划问题时首先要问自己这么几个问题：</p><ol><li>单元格中的值是什么？或者说 在动态规划中，你要将哪个<strong>指标最大化</strong>？</li><li>如何将这个问题划分为子问题？</li><li>网格的坐标轴是什么？</li><li>应该使用什么样的公式来填充每个单元格？</li></ol><h3 id="所谓费曼算法">所谓费曼算法</h3><p>​动态规划实际上比较棘手的部分就是对动态规划问题的建模这一块，但有时你就是不确定具体到底该怎么做。这时，计算机科学家会开玩笑说：不妨就使用<strong>费曼算法（Feynman algorithm）</strong>。这个算法是以著名物理学家 理查德·费曼 命名的，算法具体步骤如下。</p><ol><li>将问题写下来。</li><li>好好思考。</li><li>将答案写下来。</li></ol><p>由此我们知道，有些算法并非精确的解决步骤，而是会帮助你理清思路的框架。</p><p>​接下来我们再来讨论三个动态规划问题，其中第一个和背包问题类似，其余两种则需要重新建模。</p><h3 id="旅游行程最优化">旅游行程最优化</h3><p>​加入你要去伦敦度假，假期两天，但你想去游览的地方有很多。由于你没法前往每个地方游览，因此如何在有限的时间内，游览地方的评分总和最高是你的目标。具体行程如下。</p><table><thead><tr><th style="text-align:center">名胜</th><th style="text-align:center">威斯敏斯特教堂(W)</th><th style="text-align:center">环球剧场(G)</th><th style="text-align:center">英国国家美术馆(N)</th><th style="text-align:center">大英博物馆(B)</th><th style="text-align:center">圣保罗大教堂(S)</th></tr></thead><tbody><tr><td style="text-align:center">时间</td><td style="text-align:center">0.5天</td><td style="text-align:center">0.5天</td><td style="text-align:center">1天</td><td style="text-align:center">2天</td><td style="text-align:center">0.5天</td></tr><tr><td style="text-align:center">评分</td><td style="text-align:center">7</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">9</td><td style="text-align:center">8</td></tr></tbody></table><p>根据上面的清单以及背包问题的公式，我们可以非常轻松地填满如下表格。</p><table><thead><tr><th style="text-align:center">名胜/时间</th><th style="text-align:center">1/2</th><th style="text-align:center">1</th><th style="text-align:center">3/2</th><th style="text-align:center">2</th></tr></thead><tbody><tr><td style="text-align:center">威斯敏斯特教堂(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td><td style="text-align:center">7(W)</td></tr><tr><td style="text-align:center">环球剧场(G)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">13(WG)</td></tr><tr><td style="text-align:center">英国国家美术馆(N)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">16(WN)</td><td style="text-align:center">22(WGN)</td></tr><tr><td style="text-align:center">大英博物馆(B)</td><td style="text-align:center">7(W)</td><td style="text-align:center">13(WG)</td><td style="text-align:center">16(WN)</td><td style="text-align:center">22(WGN)</td></tr><tr><td style="text-align:center">圣保罗大教堂(S)</td><td style="text-align:center">8(S)</td><td style="text-align:center">15(WS)</td><td style="text-align:center">21(WGS)</td><td style="text-align:center">24(WNS)</td></tr></tbody></table><h3 id="最长公共子串">最长公共子串</h3><blockquote><p>有必要提前声明的是，<strong>最长公共子串</strong>讲究的是字符之间的连续性的，即 <strong>绝对顺序</strong>。相反，<strong>最长公共子序列</strong>讲究的是字符之间的<strong>相对顺序</strong>。举个例子，fosh 和 fish 的最长公共子串的长度为 2，最长公共子序列的长度为 3。fosh 和 fort 的最长公共子串的长度也是 2，但最长公共子序列的长度只有 2。</p></blockquote><p>​FISH 和 HISH 的最长公共子串的长度为多少？相信我们都可以一眼看出来，但对于计算机来说是要设计专门的算法来处理这样的问题的。<br>​首先判断这本质上应该是个动态规划问题，毫无疑问，这些个单词都可以分为单个离散的字符。并且，对于 FISH 来说 HISH 本身就是约束条件，反过来也一样。所要优化的指标当然也就是两者的 公共子串的长度。</p><p>根据以上分析判断这是个动态规划问题之后直接上网格表。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">H</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">I</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">S</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">H</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>针对单元格中索要填入的的值，思考公式是什么。<strong>再次强调一下，公式只是表象，其内部还是子问题的保存和调用的一个尾递归。</strong></p><ol><li>如果两个字母不相同时，值 =  0。</li><li>如果两个字母相同时，值 = 左上角单元格的值 + 1。</li></ol><p>实现这个公式的伪代码类似于下面这样。</p><pre><code>if word_a[j] == word_b[j]:# 两个字母相同    cell[i][j] = cell[i-1][j-1] + 1else:    cell[i][j] = 0# 两个字母不同</code></pre><p>根据公式不难填满得到如下表格。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">H</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr></tbody></table><p>同理，HISH 和 VISTA 的最长公共子串如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">V</th><th style="text-align:center">I</th><th style="text-align:center">S</th><th style="text-align:center">T</th><th style="text-align:center">A</th></tr></thead><tbody><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>需要注意的是，最终的答案并不总在最后一个单元格中。</p><h3 id="最长公共子序列">最长公共子序列</h3><p>同样，利用上面的分析方法，也可以得到动态规划最长公共子序列的公式。</p><ol><li>如果两个字母不同，就选择上方和左边的单元格的值较大的哪个。</li><li>如果两个字母相同，就将当前单元格的值设置为左上方的单元格的值加 1。</li></ol><p>公式伪代码如下。</p><pre><code>if word_a[i] == word_b[j]:# 两个字母相同    cell[i][j] = cell[i-1][j-1] + 1else:# 两个字母不同    cell[i][j] = max(cell[i-1][j],cell[i][j-1])</code></pre><p>求 FOSH 和 FORT 的最长公共子序列的长度的网格如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">F</th><th style="text-align:center">O</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">T</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr></tbody></table><p>求 FOSH 和 FISH 的最长公共子序列的长度的网格如下。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">F</th><th style="text-align:center">O</th><th style="text-align:center">S</th><th style="text-align:center">H</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><h3 id="动态规划的实际应用">动态规划的实际应用</h3><ul><li>生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。</li><li>你使用过诸如 git diff 等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。</li><li>前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li><li>你使用过诸如 Microsoft Word 等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！</li></ul><h2 id="K最近邻算法">K最近邻算法</h2><blockquote><p>​有些人说 网易云音乐 和 哔哩哔哩 有着一些 朋友交易。~~（举个例子，自己刚在哔哩哔哩看了触手猴翻奏了萃香的曲子的视频，不一会儿打开网易云音乐，首页上就推荐了 东方萃梦想/碎月/萃梦想 的同人曲歌单。）~~这其中的机制就和 <strong>K最近邻算法</strong>有关系。</p></blockquote><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%8D%E6%98%8E%E9%A3%9F%E7%89%A9.png" alt></p><p>​如上图，现在桌子上有一个水果，现在它只可能是橙子或者柚子中的一种，你不能直接问卖水果的人。手头上已知的条件是：**柚子通常比橙子更大、更红。**现在的问题是它最有可能是橙子还是柚子？</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E6%A0%87.png" alt></p><p>​不妨在脑内想象一个这么样的图表，其中 O 为橙子，G 为柚子，横坐标为大小，纵坐标为颜色的深浅。注意到，<strong>坐标轴是连续的，而水果则抽象成了一些离散的点，或者说向量。</strong><br>​那么如何大致判断这个神秘的水锅到底是什么呢？其实非常简单，不妨找一下离 神秘水果所表示的点 最近的三个水果，然后比较以下那种水果的种类更多即可。若假定 3个水果中，有两个都是橙子，那么这个神秘水果很有可能就是橙子。</p><h3 id="KNN算法">KNN算法</h3><p>​在判断那个水果的种类的过程中，其实已经使用了 K最近邻（k-nearest neighbours, KNN）算法。利用自然语言描述刚刚的 KNN算法过程如下。</p><ol><li>需要对一个水果进行分类。</li><li>查看它 K个最近的邻居。</li><li>在这些邻居中，橙子多余柚子，因此它很可能是橙子。</li></ol><p><strong>要对东西进行分类时，可以首先考虑采用 KNN算法。<strong>你可以使用 KNN 来做两项基本工作——<strong>分类</strong>和</strong>回归（regression）</strong>。</p><ul><li>分类就是编组；</li><li>回归就是预测结果。</li></ul><h3 id="特征抽取">特征抽取</h3><p>抽取特征时，要挑准合适的特征。</p><ol><li>抓准与之紧密相关的特征；</li><li>不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断它们是否喜欢动作片）。</li></ol><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E4%B8%AA%E6%B0%B4%E6%9E%9C.jpg" alt></p><p>​在前面的水果示例中，你根据个头和颜色来比较水果，换言之，你比较的特征是个头和颜色。现在假设有三个水果，你可<strong>抽取它们的特征</strong>。很明显，A 和 B 直观看起来十分相似，但事实上具体多少相似我们还是可以通过 KNN算法 来解决。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.jpg" alt></p><p>​横坐标表示 个头，纵坐标表示 红的程度，因此，我们可以把这三个点用坐标表示出来。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">(2,2)</td><td style="text-align:center">(2,1)</td><td style="text-align:center">(4,5)</td></tr></tbody></table><p>​再利用毕达哥拉斯公式不难算出每两点之间空间距离，并标在图表上。因为 A 与 B 两点之间的距离最短，因此它们俩是最像的，这也印证了之间的直觉。</p><h3 id="回归">回归</h3><p>​假定你在你的老家卖冰棍，由于是夏天，卖地比较火，因此每天都要进货一些新的冰棍。每天的进货量由下面几个指标进行预测。</p><ol><li>天气指数 1~5（数字越大 代表 气温越高）；</li><li>是否是周末或节假日（周末或节假日为 1，否则为 0）；</li><li>有无活动（有为 1，否则为 0）。</li></ol><p>​之后，你测了 1个月的数据，记录了在各种不同的日子里卖出的冰棍数量。在这 30天的容量中，你选出 6天的数据作为样本，如下表所示。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">(5,1,0)</td><td style="text-align:center">(3,1,1)</td><td style="text-align:center">(1,1,0)</td><td style="text-align:center">(4,0,1)</td><td style="text-align:center">(4,0,0)</td><td style="text-align:center">(2,0,0)</td></tr><tr><td style="text-align:center">300根</td><td style="text-align:center">225根</td><td style="text-align:center">75根</td><td style="text-align:center">200根</td><td style="text-align:center">150根</td><td style="text-align:center">50根</td></tr></tbody></table><p>​今天是周末，气温比较高，店里也没有办什么活动，点坐标为（4,1,0）。根据以上数据，你要预测今天大概能卖出去多少根冰棍。只要学过高中数学，就知道这就是个典型的回归问题，但有稍微有点不一样。由于之前说过 KNN算法就是用来解决<strong>编组</strong>和<strong>回归</strong>问题的，因此我们要用 KNN算法来解决。<br>​利用毕达哥拉斯公式可以算出“今天”与A,B,C,D,E,F点之间的距离，如下所示。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">9</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">5</td></tr></tbody></table><p>​K 取 4 时，与（4,1,0）最近的邻居为 A、B、D 和 E。将这些天售出的冰棍数平均，结果为 218.75。<strong>这就是回归（regression）。</strong></p><h3 id="余弦相似度">余弦相似度</h3><p>​前面计算两位用户的距离时，使用的都是<strong>距离公式</strong>。但在实际工作中，则经常会使用**余弦相似度（cosine similarity）**来量化两位用户的相似程度。余弦相似度不计算两个矢量的距离，而比较它们角度，如果要深入研究，那就是另一个话题了。</p><p>​到这里不妨试着猜想一下开头提及的原理。网易云首先为每个注册的用户生成一个“用户画像”（Persona），即 将用户的每个具体信息抽象成标签，利用这些标签将用户形象具体化，从而为用户提供有针对性的服务。其中将每个具体信息抽象成标签的过程可能就要用到 K最近邻算法，不过这里的空间维数可能要达到千以上的数量级，并且每一维都有各自的权重。同理，哔哩哔哩也可能采用这样机制。<br>​但哔哩哔哩和网易云音乐可能没有直接的关系。不妨假定在网易云音乐中，用户A 与 用户B 之间的标签十分相似。相似到什么程度呢？一旦 A “喜欢”了一首歌，就会立即反映到当天 B 的推荐歌曲中。接下来的说法要建立在一个前提之上，就是 这种类型的歌曲的听众 可以映射到 哔哩哔哩 的一个较小的“圈子”中。比如，喜欢听 二刺螈 的曲子的人 在哔哩哔哩中可能是混“番剧”这个圈子的。那么就有这种可能，十月新番 在 哔哩哔哩 准时开播，假定 番剧 和 OP 是同时上架的，A 第一时间追了一集之后马上去网易云音乐对 OP 点了“喜欢”。在这之后，B 也追完了，无意打开网易云发现首页上竟然有 自己正在追的动画的 OP，于是在曲子的评论中不禁如下感叹。（当然这不是我，<s>废话。</s>）<br><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/py%E4%BA%A4%E6%98%93.png" alt></p><h3 id="简述机器学习">简述机器学习</h3><p>​KNN算法在神奇的机器学习领域也占有一定的比重。<strong>机器学习</strong>皆在让计算机更聪明。<strong>创建推荐系统</strong>，就是个机器学习的例子。</p><h4 id="OCR">OCR</h4><p>​OCR 指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我们来看一个例子。请看下面的数字。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.jpg" alt></p><p>如何自动识别出这个数字是什么呢？我们当然可以使用 KNN。</p><ol><li>浏览大量的数字图像，将这些数字的特征提取出来。这在机器学习中被称之为<strong>训练（training）</strong>。</li><li>遇到新图像时，提取该图像的特征，再找出它最近的邻居都是谁。</li></ol><p>​与前面的水果示例相比，OCR 中的特征提取明显要复杂得多得多，但再复杂的技术也是基于 KNN 等简单理念的。而这些理念也可用于语音识别和人脸识别。当你将照片你上传到 Facebook 时，它有时候能够自动标出照片中的任务，这正是机器学习在发挥作用。</p><h4 id="创建垃圾邮件过滤器">创建垃圾邮件过滤器</h4><p>​垃圾邮件过滤器用的并非 KNN 算法，而是另一种基本算法——<strong>朴素贝叶斯分类器（Naive Bayes classifier）</strong>。大多数机器学习算法都包括训练的步骤：要让计算机完成任务，必须先训练它。垃圾邮件过滤器也不再例外，因此你需要使用一定量的数据对这个分类器进行训练。垃圾邮件过滤器可以计算出一个任意一个邮件为垃圾邮件的概率，其应用领域与 KNN 相似。<br>​你甚至还可以用朴素贝叶斯分类器对之前提到的水果进行分类：假设有一个又红又大的水果，它是柚子的概率是多少呢？……</p><h4 id="预测股票市场">预测股票市场</h4><p>未来很难预测，由于涉及的变量太多，这几乎是不可能完成的任务。</p><h2 id="最后再介绍十种数据结构和算法">最后再介绍十种数据结构和算法</h2><h3 id="树">树</h3><p>​每当用户登录自己的 B 站 账号时，都要从庞大的数据中去查找，并判断是否存在这样 ID。倘若你要设计 B 站 用户的登陆系统，你会选择什么样的<strong>数据结构</strong>来存储用户 ID 以及 算法用来查找 ID。<br>​如果使用二分查找，并使用极其庞大的数组来存储数据，那么注销和注册一个 ID 将是个极其麻烦的工作。为此，有人设计了一种名为**二叉查找树（binary search tree）**的数据结构，来减轻算法的负担。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><p>​二叉查找树类似于上面这样。这种数据结构形象地表示出来之后长相酷似“树”，因此命名为二叉查找树，其实是一种变异的“链表”。也拜这种结构所赐，使得数据的增删变得极其地方便。其中，树的最顶端被称为<strong>根节点</strong>，其余节点被称为<strong>子节点</strong>。而<strong>对于其中每个节点，左子节点的值都比它小，右子节点的值都比它大。</strong><br>​对于树的查找，其原理与二分查找相似，因此<strong>平均</strong>时间复杂度都为 O(log n)。举个例子，假设我要在上面 5个数据中查找“Maggie”。为此，我首先检查根节点是否为“Maggie”，发现匹配失败之后，发现“Maggie”应该排在“David”的后面，因此我往右边找。“Maggie”应该排在“Manning”前面，于是接着往左边找，最终找到了“Maggie”。<br>​与其它大部分数据结构不同的是，树自己本身是存在<strong>优劣</strong>的，即 有好的“树”，也有“坏”的树。<strong>一颗树中两个分叉的子树数量比例越高，树的性能就越佳。</strong></p><p>👍🌲⬇️</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A5%BD%E7%9A%84%E6%A0%91.png" alt></p><p>👎🌲⬇️</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9D%8F%E7%9A%84%E6%A0%91.png" alt></p><p>​第一棵树正在处于<strong>平衡状态</strong>，此时的最糟的运行时间为 O(log n)。第二棵树处于<strong>非平衡状态</strong>，此时的最遭的运行时间为 O(n)，仿佛整棵树马上就要向左倒下来。由于树与链表相似，都不支持随机访问，二叉查找树处于平衡状态时，平均访问时间为 O(log n)。</p><p>下面给出一下数组和二叉查找树的性能。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">二叉查找树</th></tr></thead><tbody><tr><td style="text-align:center">查找</td><td style="text-align:center">O(log n)</td><td style="text-align:center">O(log n)</td></tr><tr><td style="text-align:center">插入</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(log n)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(log n)</td></tr></tbody></table><p>​此外，还有几种特殊的二叉查找树，如 <strong>B树</strong>、<strong>红黑树</strong>、<strong>堆</strong>、<strong>伸展树</strong> 等，当然这就是另一个故事了。</p><h3 id="反向索引">反向索引</h3><p>这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E4%BB%AC.jpg" alt></p><p>我们根据这些内容船舰一个散列表。</p><p><img src="/2020/01/30/%E5%88%9D%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E9%A1%B5%E6%95%A3%E5%88%97%E8%A1%A8.jpg" alt></p><p>​这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜索 hi，在这种情况下，搜索引擎需要检查哪些页面包含 hi。<br>​搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜索 there。你知道，页面 A 和 C 包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散列表，将单词映射到包含它的页面。这种数据结构被称为<strong>反向索引（inverted index）</strong>，常用于创建搜索引擎。如果对搜索感兴趣，从反向索引着手研究是不错的选择。</p><h3 id="傅里叶变换">傅里叶变换</h3><p>  绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。<br>  这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理。<br>  数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。<br>  使用傅里叶变换可创建类似于 Shazam 这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高。</p><p>接下来的三个主题斗鱼可扩展性和海量数据处理相关。</p><h3 id="并行算法">并行算法</h3><p>  我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们能够在多个内核中并行地执行！<br>  来看一个简单的例子。在最佳情况下，排序算法的速度大致为 O(n log n)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)。对数组进行排序时，快速排序的并行版本所需的时间为 O(n)。<br>  并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。</p><ul><li><strong>并行性管理开销</strong>。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。</li><li><strong>负载均衡</strong>。假设你需要完成 10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么 50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？</li></ul><h3 id="MapReduce">MapReduce</h3><p>  有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce 是一种流行的分布式算法，你可通过流行的开源工具 Apache Hadoop 来使用它。</p><h4 id="分布式算法为何很有用">分布式算法为何很有用</h4><p>  假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过Hadoop来使用MapReduce！<br>  又假设你需要处理一个很长的清单，其中包含100万个职位，而每个职位处理起来需要10秒。如果使用一台计算机来处理，将耗时数月！如果使用100台计算机来处理，可能几天就能完工。<br>  分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：**映射（map）<strong>函数和</strong>归并（reduce）**函数。MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用 MapReduce 只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。</p><h2 id="布隆过滤器和HyperLogLog">布隆过滤器和HyperLogLog</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Java 语法学习</title>
      <link href="/2020/01/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Java%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要</strong>：Thinkingear 的 Java 自学第一步</p><a id="more"></a><p><strong>阅前须知</strong>：这是一个语法学习向的文章，仅供参考，实际效果因人而异。<br><strong>文章预计完成时间</strong>：15d<br><strong>文章实际完成时间</strong>：打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]，打卡[]。</p><h1 id="前言">前言</h1><p>​这篇文章主要涵盖了 Java 的一些基础语法。虽说文章的标题写明了 <code>从零开始的Java 语法学习</code>，但其实学校之前是有开过 Python 这门语言的课程的，但学的都是些皮毛中的皮毛，并且没有再额外接触过 Java 相关的东西，所以……废话就说到这。</p><h1 id="正文">正文</h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入坑Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学计算机网络前瞻</title>
      <link href="/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/"/>
      <url>/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要</strong>：主要给出了初学计算机网路时整体的知识框架以及学习要求</p><a id="more"></a><p><strong>读者定位</strong>：对没有接触过计算机网络但希望了解并学习的人群，给出了一个大致的 学习框架以及一系列基本要求。</p><p><strong>阅前须知</strong>：本文的所有内容都由程序🐏提供，更多内容请移步至羊哥的公众号(CodeSheep)，<a href="https://space.bilibili.com/384068749" target="_blank" rel="noopener">B站空间</a> 或 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">个人博客</a>。</p><blockquote><p>计算机网络主要指的就是 TCP/IP 协议栈，TCP/IP已然称为互联网的基石，甚至可以被称作是互联网时代最伟大的发明。但学习 TCP/IP 技术栈被人饱受诟病的一点是 TCP/IP 大部分内容都封装在操作系统内核态，总是藏着掖着，老是见不得人，因此容易遗忘，学起来就比较痛苦。</p></blockquote><h2 id="一、TCP-IP协议体系的认知">一、TCP/IP协议体系的认知</h2><p>​    TCP/IP 协议栈是一种分层的协议，自下而上依次包括 <strong>数据链路层</strong>、<strong>网络层</strong>(IP)、<strong>传输层</strong>(TCP,UDP)以及<strong>应用层</strong>(DNS,FTP,HTTPS,HTTP)。除了应用层是封装在<strong>用户空间</strong>中的，其余三层都是封装在<strong>操作系统内核空间</strong>中的，例如 Windows，Linux 操作系统内部当中。<br>​       此外，用户最经常接触的就是应用层的协议，而被封装在操作系统内核空间的三层是不容易&quot;看&quot;到的。并且下一层对上一层是透明的，传输在每一层都是对等的。</p><h2 id="二、数据链路层">二、数据链路层</h2><p>需要掌握：</p><ol><li>以太网帧的格式</li><li>MTU 的概念</li><li>ARP/rARP 协议：地址解析/逆地址解析<ul><li>可以理解为链路层和网络层之间的中间协议</li><li>ARP 查询原理，ARP 的报文格式，ARP 缓存格式</li></ul></li></ol><h2 id="三、网络层">三、网络层</h2><p>需要掌握：</p><ol><li><p>IP 首部格式：如 16位分片标识、DF 不分片标志、MF 多分片标志、13位片偏移、8位生存时间TTL、16位的首部检查</p></li><li><p>IP 分片：</p><ul><li><p>给一个很长的数据包，它的总长度大于它的 MTU值时，必定要带来 IP 分片的问题，需要画出各个分片的情况。</p></li><li><p>如何避免 IP 分片：在应用层、传输层做限制</p></li><li><p>如何确定分片的顺序</p></li><li><p>接收端如何确定所有的 IP 分片全部到达</p></li></ul></li><li><p>IP 选路 — 路由表(route print)</p><ul><li>路由表中每个字段代表什么含义</li></ul></li><li><p>ICMP 协议</p><ul><li>可以理解为网络层和传输层之间的中间协议</li><li>ICMP 协议的报文格式</li><li>报文的两大分类，即 查询 + 报错</li><li>2种查询报文 + 5种差错报文</li></ul></li></ol><h2 id="四、传输层">四、传输层</h2><p>需要掌握：</p><ol><li>UDP 协议<ul><li>UDP 协议的特点 + 首部各个字段</li><li>伪包头</li></ul></li><li>TCP 协议<ul><li>TCP 协议的特点 + 首部字段 + 面向连接可靠机制</li><li>TCP 流量控制机制<ul><li>三次握手、四次挥手，同时打开、关闭、半关闭</li></ul></li><li>TCP 流量控制机制<ul><li>滑动窗口、慢启动、拥塞避免、快速重传、快速恢复</li></ul></li><li>TCP 超时重传机制<ul><li>定时器的应用</li></ul></li><li>伪包头</li></ul></li></ol><h2 id="五、应用层">五、应用层</h2><p>需要掌握</p><ol><li><p>DNS 协议</p><ul><li><p>域名到 IP 地址的 DNS 解析映射</p></li><li><p>名字空间</p></li><li><p>DNS 指针查询中的 反向查找 或 逆向解析 的基本原理</p></li><li><p>DNS 缓存</p></li></ul></li><li><p>FTP 协议</p><ul><li>网络界的活化石……</li><li>FTP 的两条连接，即 控制流 + 数据流</li><li>FTP 的两种工作模式，即 PASV + PORT</li><li>FTP 的各种指令 + 响应码</li><li>FTP 的断点续传 + 匿名 FTP</li></ul></li><li><p>HTTP 协议</p><ul><li>报文格式，即 请求报文 + 响应报文</li><li>报文头的各种字段</li><li>HTTP 各种字段码</li></ul></li><li><p>HTTPS 协议</p><ul><li>HTTPS 的详细握手过程</li><li>摘要算法、数字签名、数字证书的原理和过程</li></ul></li></ol><p>大佬的见解：</p><p><img src="/2020/01/27/%E5%88%9D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%89%8D%E7%9E%BB/%E5%A4%A7%E4%BD%AC%E7%9A%84%E8%A7%81%E8%A7%A3.PNG" alt="大佬的见解"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑 Java 开发前瞻指南</title>
      <link href="/2020/01/27/%E5%85%A5%E5%9D%91%20Java%20%E5%BC%80%E5%8F%91%E5%89%8D%E7%9E%BB%E6%8C%87%E5%8D%97/"/>
      <url>/2020/01/27/%E5%85%A5%E5%9D%91%20Java%20%E5%BC%80%E5%8F%91%E5%89%8D%E7%9E%BB%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要</strong>：主要给出了 Java开发的一般路线</p><a id="more"></a><p><strong>阅前须知</strong>：这是一个整理向的文章，仅供参考，实际效果因人而异。本文的所有内容都由程序🐏提供，更多内容请移步至羊哥的公众号(CodeSheep)，<a href="https://space.bilibili.com/384068749" target="_blank" rel="noopener">B站空间</a> 或 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">个人博客</a>。</p><blockquote><p>为什么选择 Java ？<br>Java 的生态圈<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>实在是太香了，各种各样的框架、开源项目，以及解决问题的方案很全。</p><p>书要看英文版的还是译版的？<br>初学一个技术的时候最好看中文版的，权威的书可以放心看中文版。如果要看英文版可以适当对照着译版看（出版社或网友翻译的都可以），没有译版可以拿他人用博客写的每章总结来代替。如果还是没有就只能摸爬滚打硬着头皮啃下去或者换一种媒介进行学习。不过我还是推荐书籍，线上线下老师讲课你都只能跟着老师的 pace 来学习，而书籍你可以随意翻页，学习自由度很高。</p></blockquote><h3 id="基础知识">基础知识</h3><ul><li>Java 编程语言的学习<ul><li>最好是配一些小练手的项目一起做</li><li>推荐书籍：<ul><li>OnJava 8：又名 Java 编程思想 第五版</li><li>Java并发编程实战：多线程、多进程的精髓</li><li>函数式编程思维：有利于提升代码的信噪比<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，提升性能</li></ul></li></ul></li><li>基本<strong>数据结构及算法</strong><ul><li>==圣经级别的重要==</li><li>推荐书籍：<ul><li>算法</li><li>剑指Offer</li><li>编程之美</li><li>编程珠玑</li></ul></li><li>刷题网站<ul><li>LeetCode</li></ul></li></ul></li><li>关注代码质量<ul><li>推荐书籍：<ul><li>重构 改善既有代码的设计</li><li>clean code</li><li>编写可读代码的艺术</li></ul></li></ul></li><li>基本的网络知识：TCP/IP HTTP/HTTPS<ul><li>Java 开发做 Web应用的居多，现在的网站、APP、小程序都是一种 Web 模型。</li><li>推荐书籍：<ul><li>TCP/IP详解卷一二三：吃透是最好的，边抓包，对照报文阅读会更有效率</li><li>计算机网络</li></ul></li></ul></li><li>基本的设计模式<ul><li>模板、策略……</li><li>推荐书籍：Head First Design Patterns</li></ul></li></ul><hr><h3 id="工具">工具</h3><ul><li>操作系统：Linux（因为很好的稳定性，实际的开发大多是在Linux上做的）<ul><li>CentOS,Ubuntu,Fedora</li><li>推荐书籍：<ul><li>UNIX 环境高级编程</li><li>鸟哥的Linux私房菜</li></ul></li></ul></li><li>代码管理：SVN / Git</li><li>持续集成（CI/CD）：Jekins</li><li>项目管理：<strong>Maven</strong> / Gradle<ul><li>有必要深入体系地学习</li></ul></li></ul><hr><h3 id="框架">框架</h3><p>框架意义就是应对复杂度，可以把很复杂的工作得到很好的精简。</p><h4 id="应用层框架">应用层框架</h4><ul><li><s>SSH (Structs +Spring + Hibernate)</s><ul><li>这个有点过时了</li></ul></li><li>SSM (Spring + Springmvc + Mybatis)<ul><li>Mybatis 数据库的访问层</li><li>推荐书籍：<ul><li>Spring MVC + MyBatis 从入门到项目实践：比较地快餐风</li></ul></li></ul></li><li>Spring Boot<ul><li>自动配置和自动装箱等等，使其成为最好上手的框架之一</li><li>推荐书籍：<ul><li>Sring 实战</li></ul></li></ul></li></ul><h4 id="中间件">中间件</h4><ul><li>消息队列 (MQ/Message Queue)：RocketMQ文档,ActiveMQ文档<ul><li>解耦、异步处理……</li></ul></li><li>通信框架 &gt; 远程过程调用 (RPC/Remote Procedure Call)<ul><li>gRPC,thrift,dubbo,nettyspringCloud,微服务 等都和 PRC 有关</li></ul></li><li>ElasticSearch（数据库/搜索引擎）</li><li>……</li></ul><h4 id="数据库">数据库</h4><ul><li>SQL / Structured Query Language (结构化查询语言)<ul><li>MySQL / Postgre SQL</li><li>推荐书籍：<ul><li>MySQL 必知必会</li><li>高性能 MySQL</li></ul></li></ul></li><li>NoSQL / Not only SQL（非结构数据库）<ul><li>Redis(高速缓存),Memcahed(缓存),mongodb(文档SQL),ElasticSearch</li><li>推荐书籍：<ul><li>Redis 入门指南：也是一本快餐式的书籍</li><li>Redis 开发与运维：相较上一本更为全面和体系化</li></ul></li></ul></li></ul><h2 id="架构">架构</h2><h4 id="分布式-微服务架构">分布式/微服务架构</h4><p>​传统开发一般是个单体开发，一味地向一个项目堆积各种功能。微服务的出现使得将功能进行拆分，形成很多个微型单元模块，之间再通过 PRC 或 HTTP 相互进行调用。</p><ul><li>Spring Cloud</li><li>dubbo</li><li>RPC 通信框架</li></ul><h4 id="虚拟化-容器化技术">虚拟化/容器化技术</h4><ul><li>Docker 容器<ul><li>类似黑盒，将内部复杂的功能屏蔽掉，<strong>应对复杂度</strong>。</li></ul></li><li>容器集群（K8S/kubernetes）<ul><li>管理容器的工具</li></ul></li></ul><h2 id="源码-性能">源码/性能</h2><p>需要有丰富的编程经验、运维经验等等，难度较高。</p><ul><li>JDK 源码以及部分设计思想</li><li>Spring 源码</li><li>JVM 细节和排错<ul><li>永恒的话题</li><li>推荐书籍：深入理解 Java 虚拟机</li></ul></li><li><strong>高并发/高可用</strong></li></ul><h2 id="技术学习方法">技术学习方法</h2><p>以学习 Spring Boot 技术为例</p><h4 id="认知、了解">认知、了解</h4><p>​这一阶段主要是掌握这个技术的相关概念和应用方向，并且由于人总有一种先入为主的观点，因此对某个技术点的第一印象非常重要，防止跑偏。</p><ul><li>了解 Spring Boot 的百科定义</li><li>Spring Boot 解决了什么问题<ul><li>Spring Boot 就是一个典型的 Web后端框架，驱动一个网站的后端，相应前端发送过来的数据。</li></ul></li><li>知道同类技术具体有哪些<ul><li>Spring Boot(Java),beego(Go),flask(Python),diango(Python),thinkphp(PHP)</li></ul></li><li>了解技术的主要组成部分<ul><li>Spring 框架的 IOC容器、AOP切面</li></ul></li><li>思考该技术为什么会出现</li></ul><h4 id="学语法、学用法">学语法、学用法</h4><p>这个过程中要 多思考、多提炼、多总结、多写博客</p><ul><li>一般视频教程<ul><li>效率较低</li></ul></li><li>快速demo搭建视频 / 快速上手视频</li><li>阅读入门级的博客</li><li>阅读权威性的书籍</li><li>阅读官方文档</li></ul><h4 id="局部练习、小型实战、搭环境">局部练习、小型实战、搭环境</h4><p>踩坑及时记录、多思考、多提炼、多提炼、谢谢博客</p><ul><li>相关语法知识点的代码练习</li><li>实战小demo</li><li>搭建环境</li></ul><h4 id="上手实际项目、开源项目">上手实际项目、开源项目</h4><p>要求网络数据结构、网络、环境、语法等基础非常牢固</p><ul><li>了解项目内容</li><li>把项目在 IDE 里跑起来</li><li>调这个开源项目</li><li>结合一些脑图、流程图、UML 类图 阅读项目代码</li><li>自定义开源项目</li></ul><h4 id="造轮子、源码阅读、Github-开源项目">造轮子、源码阅读、Github 开源项目</h4><p>最高境界……</p><h2 id="理论课程选择">理论课程选择</h2><h4 id="计算机基础理论课">计算机基础理论课</h4><p>直接决定自身的一个计算机的素养，以及学习并理解新技术的深度。</p><ul><li>《计算机导论》</li><li>《计算机体系结构》</li><li>《计算机系统结构》</li><li>《计算机组成原理》</li><li>《微型计算机技术》</li></ul><h4 id="软件工程基础理论课">软件工程基础理论课</h4><ul><li>《软件工程》</li><li>《软件架构》</li></ul><h4 id="操作系统">操作系统</h4><ul><li>《操作系统》</li></ul><h4 id="数据结构">数据结构</h4><ul><li>《数据结构》</li></ul><h4 id="计算机网络">计算机网络</h4><ul><li>《计算机网络》</li></ul><h4 id="程序设计语言">程序设计语言</h4><ul><li>《Java 程序设计语言》</li><li>《C 程序语言设计》</li></ul><h4 id="数据库-v2">数据库</h4><ul><li>《数据库》</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>编程的目的是产生实用的<strong>程序和软件</strong>，仅仅语言本身是很难实现这个目的的。<strong>语言</strong>之外，还要有<strong>编译器</strong>、<strong>集成开发环境（IDE）</strong>、 <strong>第三方功能模块</strong>、<strong>帮助文档</strong>等等，此外还要有<strong>技术社区</strong>供编程者交流和学习。这些东西合起来，就是一个==生态环境==。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>即 用极少数的代码完成比较完整的功能，但不宜重构 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入坑Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
